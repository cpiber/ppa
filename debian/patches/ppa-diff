Description: Changes not included in original tarball
 .
 bluez (5.72-ppa1.1) jammy; urgency=medium
 .
   * Add experimental flag
Author: Constantin Piber <cp.piber@gmail.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout https://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: (upstream|backport|vendor|other), (<patch-url>|commit:<commit-id>)
Bug: <upstream-bugtracker-url>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: (no|not-needed|<patch-forwarded-url>)
Applied-Upstream: <version>, (<commit-url>|commit:<commid-id>)
Reviewed-By: <name and email of someone who approved/reviewed the patch>
Last-Update: 2024-05-10

--- /dev/null
+++ ppa/.checkpatch.conf
@@ -0,0 +1,15 @@
+--no-tree
+--no-signoff
+--summary-file
+--show-types
+--max-line-length=80
+
+--ignore COMPLEX_MACRO
+--ignore SPLIT_STRING
+--ignore CONST_STRUCT
+--ignore FILE_PATH_CHANGES
+--ignore MISSING_SIGN_OFF
+--ignore PREFER_PACKED
+--ignore COMMIT_MESSAGE
+--ignore SSCANF_TO_KSTRTO
+--ignore SPDX_LICENSE_TAG
--- /dev/null
+++ ppa/.gitlint
@@ -0,0 +1,48 @@
+# All these sections are optional, edit this file as you like.
+# [general]
+# ignore=title-trailing-punctuation, T3
+# verbosity should be a value between 1 and 3, the commandline -v flags take precedence over this
+# verbosity = 2
+# By default gitlint will ignore merge commits. Set to 'false' to disable.
+# ignore-merge-commits=true
+# Enable debug mode (prints more output). Disabled by default.
+# debug=true
+
+# Set the extra-path where gitlint will search for user defined rules
+# See http://jorisroovers.github.io/gitlint/user_defined_rules for details
+# extra-path=examples/
+
+[title-max-length]
+line-length=72
+
+# [title-must-not-contain-word]
+# Comma-separated list of words that should not occur in the title. Matching is case
+# insensitive. It's fine if the keyword occurs as part of a larger word (so "WIPING"
+# will not cause a violation, but "WIP: my title" will.
+# words=wip
+
+# [title-match-regex]
+# python like regex (https://docs.python.org/2/library/re.html) that the
+# commit-msg title must be matched to.
+# Note that the regex can contradict with other rules if not used correctly
+# (e.g. title-must-not-contain-word).
+# regex=^US[0-9]*
+
+# [B1]
+# B1 = body-max-line-length
+# line-length=120
+
+[body-min-length]
+min-length=1
+
+# [body-is-missing]
+# Whether to ignore this rule on merge commits (which typically only have a title)
+# default = True
+# ignore-merge-commits=false
+
+# [body-changed-file-mention]
+# List of files that need to be explicitly mentioned in the body when they are changed
+# This is useful for when developers often erroneously edit certain files or git submodules.
+# By specifying this rule, developers can only change the file when they explicitly reference
+# it in the commit message.
+# files=gitlint/rules.py,README.md
--- /dev/null
+++ ppa/HACKING
@@ -0,0 +1,151 @@
+Hacking on BlueZ
+****************
+
+Build tools requirements
+========================
+
+When building and testing directly from the repository it is important to
+have at least automake version 1.10 or later installed.
+
+
+Working with the source code repository
+=======================================
+
+The repository contains two extra scripts that accomplish the bootstrap
+process. One is called "bootstrap" which is the basic scripts that uses the
+autotools scripts to create the needed files for building and installing.
+It makes sure to call the right programs depending on the usage of shared or
+static libraries or translations etc.
+
+The second program is called "bootstrap-configure". This program will make
+sure to properly clean the repository, call the "bootstrap" script and then
+call configure with proper settings for development. It will use the best
+options and pass them over to configure. These options normally include
+the enabling the maintainer mode and the debugging features.
+
+So while in a normal source project the call "./configure ..." is used to
+configure the project with its settings like prefix and extra options. In
+case of bare repositories call "./bootstrap-configure" and it will bootstrap
+the repository and calls configure with all the correct options to make
+development easier.
+
+In case of preparing for a release with "make distcheck", don't use
+bootstrap-configure since it could export development specific settings.
+
+So the normal steps to checkout, build and install such a repository is
+like this:
+
+  Checkout repository
+    # git clone git://git.kernel.org/pub/scm/bluetooth/bluez.git
+    # cd bluez
+
+  Configure and build
+    # ./bootstrap-configure
+    # make
+
+  Configure and build with cgcc (Sparse)
+    # ./bootstrap-configure CC=cgcc
+    # make
+
+  Run unit tests
+    # make check
+
+  Check installation
+    # make install DESTDIR=$PWD/x
+    # find x
+    # rm -rf x
+
+  Check distribution
+    # make distcheck
+
+  Final installation
+    # sudo make install
+
+  Remove autogenerated files
+    # make maintainer-clean
+
+
+Running from within the source code repository
+==============================================
+
+When using "./configure --enable-maintainer-mode" the automake scripts will
+use the plugins directly from within the repository. This removes the need
+to use "make install" when testing "bluetoothd". The "bootstrap-configure"
+automatically includes this option.
+
+  Copy configuration file which specifies the required security policies
+    # sudo cp ./src/bluetooth.conf /etc/dbus-1/system.d/
+
+  Disable SELinux
+    # sudo setenforce 0
+
+  Run daemon in foreground with debugging
+    # sudo ./src/bluetoothd -n -d -f ./src/main.conf
+
+  Run daemon with valgrind
+   # sudo valgrind --trace-children=yes --track-origins=yes --track-fds=yes \
+   --show-possibly-lost=no --leak-check=full --suppressions=./tools/valgrind.supp \
+   ./src/bluetoothd -n -d -f ./src/main.conf
+
+For production installations or distribution packaging it is important that
+the "--enable-maintainer-mode" option is NOT used.
+
+Note multiple arguments to -d can be specified, colon, comma or space
+separated. The arguments are relative source code filenames for which
+debugging output should be enabled; output shell-style globs are
+accepted (e.g.: 'plugins/*:src/main.c').
+
+Submitting patches
+==================
+
+If you fixed a bug or you want to add support for something, patches are
+welcome! In order to ease the inclusion of your patch, it's important to follow
+some rules, otherwise it will likely be rejected by maintainers.
+
+Make sure the author name and email are set properly:
+
+  # git config --global user.name <name>
+  # git config --global user.email <email>
+
+The preferred way to send patches is by email, using git send-email:
+
+  # git config --global sendemail.smtpencryption <tls>
+  # git config --global sendemail.smtpserver <smtp.gmail.com>
+  # git config --global sendemail.smtpuser <yourname@gmail.com>
+  # git config --global sendemail.smtpserverport <587>
+  # git config sendemail.to linux-bluetooth@vger.kernel.org
+
+BlueZ rules for submitting patches follow most of the rules used by Linux kernel
+(https://www.kernel.org/doc/Documentation/SubmittingPatches) with some remarks:
+
+1) Do *not* add "Signed-off-by" lines in your commit messages. BlueZ does not
+use them, so including them is actually an error.
+
+2) Be sure to follow the coding style rules of BlueZ. They are listed in
+doc/coding-style.txt.
+
+3) Split your patch according to the top-level directories. E.g.: if you added
+a feature that touches files under 'include/', 'src/' and 'drivers/'
+directories, split in three separated patches, taking care not to
+break compilation.
+
+4) Bug fixes should be sent first as they take priority over new features.
+
+5) The commit message should follow 50/72 formatting which means the header
+should be limited to 50 characters and the description should be wrapped at 72
+characters except if it contains quoted information from debug tools like
+backtraces, compiler errors, etc.
+
+6) Prefix the email subject with [PATCH BlueZ]:
+
+  # git config format.subjectprefix "PATCH BlueZ"
+
+7) Add a cover letter when introducing a new feature explaning what problem
+you're trying to solve:
+
+  # git format-patch --cover-letter -M origin/master -o outgoing/
+  # edit outgoing/0000-*
+
+8) Submit:
+
+  # git send-email outgoing/*
--- /dev/null
+++ ppa/LICENSES/dual/Apache-2.0
@@ -0,0 +1,187 @@
+Valid-License-Identifier: Apache-2.0
+SPDX-URL: https://spdx.org/licenses/Apache-2.0.html
+Usage-Guide:
+  Do NOT use. The Apache-2.0 is not GPL2 compatible. It may only be used
+  for dual-licensed files where the other license is GPL2 compatible.
+  If you end up using this it MUST be used together with a GPL2 compatible
+  license using "OR".
+  To use the Apache License version 2.0 put the following SPDX tag/value
+  pair into a comment according to the placement guidelines in the
+  licensing rules documentation:
+    SPDX-License-Identifier: Apache-2.0
+License-Text:
+
+Apache License
+
+Version 2.0, January 2004
+
+http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+1. Definitions.
+
+"License" shall mean the terms and conditions for use, reproduction, and
+distribution as defined by Sections 1 through 9 of this document.
+
+"Licensor" shall mean the copyright owner or entity authorized by the
+copyright owner that is granting the License.
+
+"Legal Entity" shall mean the union of the acting entity and all other
+entities that control, are controlled by, or are under common control with
+that entity. For the purposes of this definition, "control" means (i) the
+power, direct or indirect, to cause the direction or management of such
+entity, whether by contract or otherwise, or (ii) ownership of fifty
+percent (50%) or more of the outstanding shares, or (iii) beneficial
+ownership of such entity.
+
+"You" (or "Your") shall mean an individual or Legal Entity exercising
+permissions granted by this License.
+
+"Source" form shall mean the preferred form for making modifications,
+including but not limited to software source code, documentation source,
+and configuration files.
+
+"Object" form shall mean any form resulting from mechanical transformation
+or translation of a Source form, including but not limited to compiled
+object code, generated documentation, and conversions to other media types.
+
+"Work" shall mean the work of authorship, whether in Source or Object form,
+made available under the License, as indicated by a copyright notice that
+is included in or attached to the work (an example is provided in the
+Appendix below).
+
+"Derivative Works" shall mean any work, whether in Source or Object form,
+that is based on (or derived from) the Work and for which the editorial
+revisions, annotations, elaborations, or other modifications represent, as
+a whole, an original work of authorship. For the purposes of this License,
+Derivative Works shall not include works that remain separable from, or
+merely link (or bind by name) to the interfaces of, the Work and Derivative
+Works thereof.
+
+"Contribution" shall mean any work of authorship, including the original
+version of the Work and any modifications or additions to that Work or
+Derivative Works thereof, that is intentionally submitted to Licensor for
+inclusion in the Work by the copyright owner or by an individual or Legal
+Entity authorized to submit on behalf of the copyright owner. For the
+purposes of this definition, "submitted" means any form of electronic,
+verbal, or written communication sent to the Licensor or its
+representatives, including but not limited to communication on electronic
+mailing lists, source code control systems, and issue tracking systems that
+are managed by, or on behalf of, the Licensor for the purpose of discussing
+and improving the Work, but excluding communication that is conspicuously
+marked or otherwise designated in writing by the copyright owner as "Not a
+Contribution."
+
+"Contributor" shall mean Licensor and any individual or Legal Entity on
+behalf of whom a Contribution has been received by Licensor and
+subsequently incorporated within the Work.
+
+2. Grant of Copyright License. Subject to the terms and conditions of this
+   License, each Contributor hereby grants to You a perpetual, worldwide,
+   non-exclusive, no-charge, royalty-free, irrevocable copyright license to
+   reproduce, prepare Derivative Works of, publicly display, publicly
+   perform, sublicense, and distribute the Work and such Derivative Works
+   in Source or Object form.
+
+3. Grant of Patent License. Subject to the terms and conditions of this
+   License, each Contributor hereby grants to You a perpetual, worldwide,
+   non-exclusive, no-charge, royalty-free, irrevocable (except as stated in
+   this section) patent license to make, have made, use, offer to sell,
+   sell, import, and otherwise transfer the Work, where such license
+   applies only to those patent claims licensable by such Contributor that
+   are necessarily infringed by their Contribution(s) alone or by
+   combination of their Contribution(s) with the Work to which such
+   Contribution(s) was submitted. If You institute patent litigation
+   against any entity (including a cross-claim or counterclaim in a
+   lawsuit) alleging that the Work or a Contribution incorporated within
+   the Work constitutes direct or contributory patent infringement, then
+   any patent licenses granted to You under this License for that Work
+   shall terminate as of the date such litigation is filed.
+
+4. Redistribution. You may reproduce and distribute copies of the Work or
+   Derivative Works thereof in any medium, with or without modifications,
+   and in Source or Object form, provided that You meet the following
+   conditions:
+
+   a. You must give any other recipients of the Work or Derivative Works a
+      copy of this License; and
+
+   b. You must cause any modified files to carry prominent notices stating
+      that You changed the files; and
+
+   c. You must retain, in the Source form of any Derivative Works that You
+      distribute, all copyright, patent, trademark, and attribution notices
+      from the Source form of the Work, excluding those notices that do not
+      pertain to any part of the Derivative Works; and
+
+   d. If the Work includes a "NOTICE" text file as part of its
+      distribution, then any Derivative Works that You distribute must
+      include a readable copy of the attribution notices contained within
+      such NOTICE file, excluding those notices that do not pertain to any
+      part of the Derivative Works, in at least one of the following
+      places: within a NOTICE text file distributed as part of the
+      Derivative Works; within the Source form or documentation, if
+      provided along with the Derivative Works; or, within a display
+      generated by the Derivative Works, if and wherever such third-party
+      notices normally appear. The contents of the NOTICE file are for
+      informational purposes only and do not modify the License. You may
+      add Your own attribution notices within Derivative Works that You
+      distribute, alongside or as an addendum to the NOTICE text from the
+      Work, provided that such additional attribution notices cannot be
+      construed as modifying the License.
+
+    You may add Your own copyright statement to Your modifications and may
+    provide additional or different license terms and conditions for use,
+    reproduction, or distribution of Your modifications, or for any such
+    Derivative Works as a whole, provided Your use, reproduction, and
+    distribution of the Work otherwise complies with the conditions stated
+    in this License.
+
+5. Submission of Contributions. Unless You explicitly state otherwise, any
+   Contribution intentionally submitted for inclusion in the Work by You to
+   the Licensor shall be under the terms and conditions of this License,
+   without any additional terms or conditions. Notwithstanding the above,
+   nothing herein shall supersede or modify the terms of any separate
+   license agreement you may have executed with Licensor regarding such
+   Contributions.
+
+6. Trademarks. This License does not grant permission to use the trade
+   names, trademarks, service marks, or product names of the Licensor,
+   except as required for reasonable and customary use in describing the
+   origin of the Work and reproducing the content of the NOTICE file.
+
+7. Disclaimer of Warranty. Unless required by applicable law or agreed to
+   in writing, Licensor provides the Work (and each Contributor provides
+   its Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS
+   OF ANY KIND, either express or implied, including, without limitation,
+   any warranties or conditions of TITLE, NON-INFRINGEMENT,
+   MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely
+   responsible for determining the appropriateness of using or
+   redistributing the Work and assume any risks associated with Your
+   exercise of permissions under this License.
+
+8. Limitation of Liability. In no event and under no legal theory, whether
+   in tort (including negligence), contract, or otherwise, unless required
+   by applicable law (such as deliberate and grossly negligent acts) or
+   agreed to in writing, shall any Contributor be liable to You for
+   damages, including any direct, indirect, special, incidental, or
+   consequential damages of any character arising as a result of this
+   License or out of the use or inability to use the Work (including but
+   not limited to damages for loss of goodwill, work stoppage, computer
+   failure or malfunction, or any and all other commercial damages or
+   losses), even if such Contributor has been advised of the possibility of
+   such damages.
+
+9. Accepting Warranty or Additional Liability. While redistributing the
+   Work or Derivative Works thereof, You may choose to offer, and charge a
+   fee for, acceptance of support, warranty, indemnity, or other liability
+   obligations and/or rights consistent with this License. However, in
+   accepting such obligations, You may act only on Your own behalf and on
+   Your sole responsibility, not on behalf of any other Contributor, and
+   only if You agree to indemnify, defend, and hold each Contributor
+   harmless for any liability incurred by, or claims asserted against, such
+   Contributor by reason of your accepting any such warranty or additional
+   liability.
+
+END OF TERMS AND CONDITIONS
--- /dev/null
+++ ppa/LICENSES/preferred/BSD-2-Clause
@@ -0,0 +1,32 @@
+Valid-License-Identifier: BSD-2-Clause
+SPDX-URL: https://spdx.org/licenses/BSD-2-Clause.html
+Usage-Guide:
+  To use the BSD 2-clause "Simplified" License put the following SPDX
+  tag/value pair into a comment according to the placement guidelines in
+  the licensing rules documentation:
+    SPDX-License-Identifier: BSD-2-Clause
+License-Text:
+
+Copyright (c) <year> <owner> . All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice,
+   this list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
--- /dev/null
+++ ppa/LICENSES/preferred/GPL-2.0
@@ -0,0 +1,355 @@
+Valid-License-Identifier: GPL-2.0
+Valid-License-Identifier: GPL-2.0-only
+Valid-License-Identifier: GPL-2.0-or-later
+SPDX-URL: https://spdx.org/licenses/GPL-2.0.html
+Usage-Guide:
+  To use this license in source code, put one of the following SPDX
+  tag/value pairs into a comment according to the placement
+  guidelines in the licensing rules documentation.
+  For 'GNU General Public License (GPL) version 2 only' use:
+    SPDX-License-Identifier: GPL-2.0-only
+  For 'GNU General Public License (GPL) version 2 or any later version' use:
+    SPDX-License-Identifier: GPL-2.0-or-later
+License-Text:
+
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+1:w
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
--- /dev/null
+++ ppa/LICENSES/preferred/LGPL-2.1
@@ -0,0 +1,503 @@
+Valid-License-Identifier: LGPL-2.1
+Valid-License-Identifier: LGPL-2.1-or-later
+SPDX-URL: https://spdx.org/licenses/LGPL-2.1.html
+Usage-Guide:
+  To use this license in source code, put one of the following SPDX
+  tag/value pairs into a comment according to the placement
+  guidelines in the licensing rules documentation.
+  For 'GNU Lesser General Public License (LGPL) version 2.1 only' use:
+    SPDX-License-Identifier: LGPL-2.1
+  For 'GNU Lesser General Public License (LGPL) version 2.1 or any later
+  version' use:
+    SPDX-License-Identifier: LGPL-2.1-or-later
+License-Text:
+
+GNU LESSER GENERAL PUBLIC LICENSE
+Version 2.1, February 1999
+
+Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+
+Everyone is permitted to copy and distribute verbatim copies of this
+license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL. It also counts as
+the successor of the GNU Library Public License, version 2, hence the
+version number 2.1.]
+
+Preamble
+
+The licenses for most software are designed to take away your freedom to
+share and change it. By contrast, the GNU General Public Licenses are
+intended to guarantee your freedom to share and change free software--to
+make sure the software is free for all its users.
+
+This license, the Lesser General Public License, applies to some specially
+designated software packages--typically libraries--of the Free Software
+Foundation and other authors who decide to use it. You can use it too, but
+we suggest you first think carefully about whether this license or the
+ordinary General Public License is the better strategy to use in any
+particular case, based on the explanations below.
+
+When we speak of free software, we are referring to freedom of use, not
+price. Our General Public Licenses are designed to make sure that you have
+the freedom to distribute copies of free software (and charge for this
+service if you wish); that you receive source code or can get it if you
+want it; that you can change the software and use pieces of it in new free
+programs; and that you are informed that you can do these things.
+
+To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights. These restrictions translate to certain responsibilities for you if
+you distribute copies of the library or if you modify it.
+
+For example, if you distribute copies of the library, whether gratis or for
+a fee, you must give the recipients all the rights that we gave you. You
+must make sure that they, too, receive or can get the source code. If you
+link other code with the library, you must provide complete object files to
+the recipients, so that they can relink them with the library after making
+changes to the library and recompiling it. And you must show them these
+terms so they know their rights.
+
+We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+To protect each distributor, we want to make it very clear that there is no
+warranty for the free library. Also, if the library is modified by someone
+else and passed on, the recipients should know that what they have is not
+the original version, so that the original author's reputation will not be
+affected by problems that might be introduced by others.
+
+Finally, software patents pose a constant threat to the existence of any
+free program. We wish to make sure that a company cannot effectively
+restrict the users of a free program by obtaining a restrictive license
+from a patent holder. Therefore, we insist that any patent license obtained
+for a version of the library must be consistent with the full freedom of
+use specified in this license.
+
+Most GNU software, including some libraries, is covered by the ordinary GNU
+General Public License. This license, the GNU Lesser General Public
+License, applies to certain designated libraries, and is quite different
+from the ordinary General Public License. We use this license for certain
+libraries in order to permit linking those libraries into non-free
+programs.
+
+When a program is linked with a library, whether statically or using a
+shared library, the combination of the two is legally speaking a combined
+work, a derivative of the original library. The ordinary General Public
+License therefore permits such linking only if the entire combination fits
+its criteria of freedom. The Lesser General Public License permits more lax
+criteria for linking other code with the library.
+
+We call this license the "Lesser" General Public License because it does
+Less to protect the user's freedom than the ordinary General Public
+License. It also provides other free software developers Less of an
+advantage over competing non-free programs. These disadvantages are the
+reason we use the ordinary General Public License for many
+libraries. However, the Lesser license provides advantages in certain
+special circumstances.
+
+For example, on rare occasions, there may be a special need to encourage
+the widest possible use of a certain library, so that it becomes a de-facto
+standard. To achieve this, non-free programs must be allowed to use the
+library. A more frequent case is that a free library does the same job as
+widely used non-free libraries. In this case, there is little to gain by
+limiting the free library to free software only, so we use the Lesser
+General Public License.
+
+In other cases, permission to use a particular library in non-free programs
+enables a greater number of people to use a large body of free
+software. For example, permission to use the GNU C Library in non-free
+programs enables many more people to use the whole GNU operating system, as
+well as its variant, the GNU/Linux operating system.
+
+Although the Lesser General Public License is Less protective of the users'
+freedom, it does ensure that the user of a program that is linked with the
+Library has the freedom and the wherewithal to run that program using a
+modified version of the Library.
+
+The precise terms and conditions for copying, distribution and modification
+follow. Pay close attention to the difference between a "work based on the
+library" and a "work that uses the library". The former contains code
+derived from the library, whereas the latter must be combined with the
+library in order to run.
+
+TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+0. This License Agreement applies to any software library or other program
+   which contains a notice placed by the copyright holder or other
+   authorized party saying it may be distributed under the terms of this
+   Lesser General Public License (also called "this License"). Each
+   licensee is addressed as "you".
+
+   A "library" means a collection of software functions and/or data
+   prepared so as to be conveniently linked with application programs
+   (which use some of those functions and data) to form executables.
+
+   The "Library", below, refers to any such software library or work which
+   has been distributed under these terms. A "work based on the Library"
+   means either the Library or any derivative work under copyright law:
+   that is to say, a work containing the Library or a portion of it, either
+   verbatim or with modifications and/or translated straightforwardly into
+   another language. (Hereinafter, translation is included without
+   limitation in the term "modification".)
+
+   "Source code" for a work means the preferred form of the work for making
+   modifications to it. For a library, complete source code means all the
+   source code for all modules it contains, plus any associated interface
+   definition files, plus the scripts used to control compilation and
+   installation of the library.
+
+    Activities other than copying, distribution and modification are not
+    covered by this License; they are outside its scope. The act of running
+    a program using the Library is not restricted, and output from such a
+    program is covered only if its contents constitute a work based on the
+    Library (independent of the use of the Library in a tool for writing
+    it). Whether that is true depends on what the Library does and what the
+    program that uses the Library does.
+
+1. You may copy and distribute verbatim copies of the Library's complete
+   source code as you receive it, in any medium, provided that you
+   conspicuously and appropriately publish on each copy an appropriate
+   copyright notice and disclaimer of warranty; keep intact all the notices
+   that refer to this License and to the absence of any warranty; and
+   distribute a copy of this License along with the Library.
+
+   You may charge a fee for the physical act of transferring a copy, and
+   you may at your option offer warranty protection in exchange for a fee.
+
+2. You may modify your copy or copies of the Library or any portion of it,
+   thus forming a work based on the Library, and copy and distribute such
+   modifications or work under the terms of Section 1 above, provided that
+   you also meet all of these conditions:
+
+   a) The modified work must itself be a software library.
+
+   b) You must cause the files modified to carry prominent notices stating
+      that you changed the files and the date of any change.
+
+   c) You must cause the whole of the work to be licensed at no charge to
+      all third parties under the terms of this License.
+
+   d) If a facility in the modified Library refers to a function or a table
+      of data to be supplied by an application program that uses the
+      facility, other than as an argument passed when the facility is
+      invoked, then you must make a good faith effort to ensure that, in
+      the event an application does not supply such function or table, the
+      facility still operates, and performs whatever part of its purpose
+      remains meaningful.
+
+   (For example, a function in a library to compute square roots has a
+    purpose that is entirely well-defined independent of the
+    application. Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must be
+    optional: if the application does not supply it, the square root
+    function must still compute square roots.)
+
+   These requirements apply to the modified work as a whole. If
+   identifiable sections of that work are not derived from the Library, and
+   can be reasonably considered independent and separate works in
+   themselves, then this License, and its terms, do not apply to those
+   sections when you distribute them as separate works. But when you
+   distribute the same sections as part of a whole which is a work based on
+   the Library, the distribution of the whole must be on the terms of this
+   License, whose permissions for other licensees extend to the entire
+   whole, and thus to each and every part regardless of who wrote it.
+
+   Thus, it is not the intent of this section to claim rights or contest
+   your rights to work written entirely by you; rather, the intent is to
+   exercise the right to control the distribution of derivative or
+   collective works based on the Library.
+
+   In addition, mere aggregation of another work not based on the Library
+   with the Library (or with a work based on the Library) on a volume of a
+   storage or distribution medium does not bring the other work under the
+   scope of this License.
+
+3. You may opt to apply the terms of the ordinary GNU General Public
+   License instead of this License to a given copy of the Library. To do
+   this, you must alter all the notices that refer to this License, so that
+   they refer to the ordinary GNU General Public License, version 2,
+   instead of to this License. (If a newer version than version 2 of the
+   ordinary GNU General Public License has appeared, then you can specify
+   that version instead if you wish.) Do not make any other change in these
+   notices.
+
+   Once this change is made in a given copy, it is irreversible for that
+   copy, so the ordinary GNU General Public License applies to all
+   subsequent copies and derivative works made from that copy.
+
+   This option is useful when you wish to copy part of the code of the
+   Library into a program that is not a library.
+
+4. You may copy and distribute the Library (or a portion or derivative of
+   it, under Section 2) in object code or executable form under the terms
+   of Sections 1 and 2 above provided that you accompany it with the
+   complete corresponding machine-readable source code, which must be
+   distributed under the terms of Sections 1 and 2 above on a medium
+   customarily used for software interchange.
+
+   If distribution of object code is made by offering access to copy from a
+   designated place, then offering equivalent access to copy the source
+   code from the same place satisfies the requirement to distribute the
+   source code, even though third parties are not compelled to copy the
+   source along with the object code.
+
+5. A program that contains no derivative of any portion of the Library, but
+   is designed to work with the Library by being compiled or linked with
+   it, is called a "work that uses the Library". Such a work, in isolation,
+   is not a derivative work of the Library, and therefore falls outside the
+   scope of this License.
+
+   However, linking a "work that uses the Library" with the Library creates
+   an executable that is a derivative of the Library (because it contains
+   portions of the Library), rather than a "work that uses the
+   library". The executable is therefore covered by this License. Section 6
+   states terms for distribution of such executables.
+
+   When a "work that uses the Library" uses material from a header file
+   that is part of the Library, the object code for the work may be a
+   derivative work of the Library even though the source code is
+   not. Whether this is true is especially significant if the work can be
+   linked without the Library, or if the work is itself a library. The
+   threshold for this to be true is not precisely defined by law.
+
+   If such an object file uses only numerical parameters, data structure
+   layouts and accessors, and small macros and small inline functions (ten
+   lines or less in length), then the use of the object file is
+   unrestricted, regardless of whether it is legally a derivative
+   work. (Executables containing this object code plus portions of the
+   Library will still fall under Section 6.)
+
+   Otherwise, if the work is a derivative of the Library, you may
+   distribute the object code for the work under the terms of Section
+   6. Any executables containing that work also fall under Section 6,
+   whether or not they are linked directly with the Library itself.
+
+6. As an exception to the Sections above, you may also combine or link a
+   "work that uses the Library" with the Library to produce a work
+   containing portions of the Library, and distribute that work under terms
+   of your choice, provided that the terms permit modification of the work
+   for the customer's own use and reverse engineering for debugging such
+   modifications.
+
+   You must give prominent notice with each copy of the work that the
+   Library is used in it and that the Library and its use are covered by
+   this License. You must supply a copy of this License. If the work during
+   execution displays copyright notices, you must include the copyright
+   notice for the Library among them, as well as a reference directing the
+   user to the copy of this License. Also, you must do one of these things:
+
+   a) Accompany the work with the complete corresponding machine-readable
+      source code for the Library including whatever changes were used in
+      the work (which must be distributed under Sections 1 and 2 above);
+      and, if the work is an executable linked with the Library, with the
+      complete machine-readable "work that uses the Library", as object
+      code and/or source code, so that the user can modify the Library and
+      then relink to produce a modified executable containing the modified
+      Library. (It is understood that the user who changes the contents of
+      definitions files in the Library will not necessarily be able to
+      recompile the application to use the modified definitions.)
+
+   b) Use a suitable shared library mechanism for linking with the
+      Library. A suitable mechanism is one that (1) uses at run time a copy
+      of the library already present on the user's computer system, rather
+      than copying library functions into the executable, and (2) will
+      operate properly with a modified version of the library, if the user
+      installs one, as long as the modified version is interface-compatible
+      with the version that the work was made with.
+
+   c) Accompany the work with a written offer, valid for at least three
+      years, to give the same user the materials specified in Subsection
+      6a, above, for a charge no more than the cost of performing this
+      distribution.
+
+   d) If distribution of the work is made by offering access to copy from a
+      designated place, offer equivalent access to copy the above specified
+      materials from the same place.
+
+   e) Verify that the user has already received a copy of these materials
+      or that you have already sent this user a copy.
+
+   For an executable, the required form of the "work that uses the Library"
+   must include any data and utility programs needed for reproducing the
+   executable from it. However, as a special exception, the materials to be
+   distributed need not include anything that is normally distributed (in
+   either source or binary form) with the major components (compiler,
+   kernel, and so on) of the operating system on which the executable runs,
+   unless that component itself accompanies the executable.
+
+   It may happen that this requirement contradicts the license restrictions
+   of other proprietary libraries that do not normally accompany the
+   operating system. Such a contradiction means you cannot use both them
+   and the Library together in an executable that you distribute.
+
+7. You may place library facilities that are a work based on the Library
+   side-by-side in a single library together with other library facilities
+   not covered by this License, and distribute such a combined library,
+   provided that the separate distribution of the work based on the Library
+   and of the other library facilities is otherwise permitted, and provided
+   that you do these two things:
+
+   a) Accompany the combined library with a copy of the same work based on
+      the Library, uncombined with any other library facilities. This must
+      be distributed under the terms of the Sections above.
+
+   b) Give prominent notice with the combined library of the fact that part
+      of it is a work based on the Library, and explaining where to find
+      the accompanying uncombined form of the same work.
+
+8. You may not copy, modify, sublicense, link with, or distribute the
+   Library except as expressly provided under this License. Any attempt
+   otherwise to copy, modify, sublicense, link with, or distribute the
+   Library is void, and will automatically terminate your rights under this
+   License. However, parties who have received copies, or rights, from you
+   under this License will not have their licenses terminated so long as
+   such parties remain in full compliance.
+
+9. You are not required to accept this License, since you have not signed
+   it. However, nothing else grants you permission to modify or distribute
+   the Library or its derivative works. These actions are prohibited by law
+   if you do not accept this License. Therefore, by modifying or
+   distributing the Library (or any work based on the Library), you
+   indicate your acceptance of this License to do so, and all its terms and
+   conditions for copying, distributing or modifying the Library or works
+   based on it.
+
+10. Each time you redistribute the Library (or any work based on the
+    Library), the recipient automatically receives a license from the
+    original licensor to copy, distribute, link with or modify the Library
+    subject to these terms and conditions. You may not impose any further
+    restrictions on the recipients' exercise of the rights granted
+    herein. You are not responsible for enforcing compliance by third
+    parties with this License.
+
+11. If, as a consequence of a court judgment or allegation of patent
+    infringement or for any other reason (not limited to patent issues),
+    conditions are imposed on you (whether by court order, agreement or
+    otherwise) that contradict the conditions of this License, they do not
+    excuse you from the conditions of this License. If you cannot
+    distribute so as to satisfy simultaneously your obligations under this
+    License and any other pertinent obligations, then as a consequence you
+    may not distribute the Library at all. For example, if a patent license
+    would not permit royalty-free redistribution of the Library by all
+    those who receive copies directly or indirectly through you, then the
+    only way you could satisfy both it and this License would be to refrain
+    entirely from distribution of the Library.
+
+    If any portion of this section is held invalid or unenforceable under
+    any particular circumstance, the balance of the section is intended to
+    apply, and the section as a whole is intended to apply in other
+    circumstances.
+
+    It is not the purpose of this section to induce you to infringe any
+    patents or other property right claims or to contest validity of any
+    such claims; this section has the sole purpose of protecting the
+    integrity of the free software distribution system which is implemented
+    by public license practices. Many people have made generous
+    contributions to the wide range of software distributed through that
+    system in reliance on consistent application of that system; it is up
+    to the author/donor to decide if he or she is willing to distribute
+    software through any other system and a licensee cannot impose that
+    choice.
+
+    This section is intended to make thoroughly clear what is believed to
+    be a consequence of the rest of this License.
+
+12. If the distribution and/or use of the Library is restricted in certain
+    countries either by patents or by copyrighted interfaces, the original
+    copyright holder who places the Library under this License may add an
+    explicit geographical distribution limitation excluding those
+    countries, so that distribution is permitted only in or among countries
+    not thus excluded. In such case, this License incorporates the
+    limitation as if written in the body of this License.
+
+13. The Free Software Foundation may publish revised and/or new versions of
+    the Lesser General Public License from time to time. Such new versions
+    will be similar in spirit to the present version, but may differ in
+    detail to address new problems or concerns.
+
+    Each version is given a distinguishing version number. If the Library
+    specifies a version number of this License which applies to it and "any
+    later version", you have the option of following the terms and
+    conditions either of that version or of any later version published by
+    the Free Software Foundation. If the Library does not specify a license
+    version number, you may choose any version ever published by the Free
+    Software Foundation.
+
+14. If you wish to incorporate parts of the Library into other free
+    programs whose distribution conditions are incompatible with these,
+    write to the author to ask for permission. For software which is
+    copyrighted by the Free Software Foundation, write to the Free Software
+    Foundation; we sometimes make exceptions for this. Our decision will be
+    guided by the two goals of preserving the free status of all
+    derivatives of our free software and of promoting the sharing and reuse
+    of software generally.
+
+NO WARRANTY
+
+15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+    FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
+    OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+    PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
+    EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
+    ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE LIBRARY IS WITH
+    YOU. SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
+    NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+    WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+    REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
+    DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
+    DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE LIBRARY
+    (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED
+    INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF
+    THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR
+    OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+
+END OF TERMS AND CONDITIONS
+
+How to Apply These Terms to Your New Libraries
+
+If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change. You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+To apply these terms, attach the following notices to the library. It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+one line to give the library's name and an idea of what it does.
+Copyright (C) year name of author
+
+This library is free software; you can redistribute it and/or modify it
+under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or (at
+your option) any later version.
+
+This library is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
+for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this library; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA Also add
+information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary. Here is a sample; alter the names:
+
+Yoyodyne, Inc., hereby disclaims all copyright interest in
+the library `Frob' (a library for tweaking knobs) written
+by James Random Hacker.
+
+signature of Ty Coon, 1 April 1990
+Ty Coon, President of Vice
+That's all there is to it!
--- /dev/null
+++ ppa/LICENSES/preferred/MIT
@@ -0,0 +1,30 @@
+Valid-License-Identifier: MIT
+SPDX-URL: https://spdx.org/licenses/MIT.html
+Usage-Guide:
+  To use the MIT License put the following SPDX tag/value pair into a
+  comment according to the placement guidelines in the licensing rules
+  documentation:
+    SPDX-License-Identifier: MIT
+License-Text:
+
+MIT License
+
+Copyright (c) <year> <copyright holders>
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the "Software"),
+to deal in the Software without restriction, including without limitation
+the rights to use, copy, modify, merge, publish, distribute, sublicense,
+and/or sell copies of the Software, and to permit persons to whom the
+Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+DEALINGS IN THE SOFTWARE.
--- /dev/null
+++ ppa/android/sco-ipc-api.txt
@@ -0,0 +1,37 @@
+Bluetooth SCO Audio Plugin
+==========================
+
+The SCO Audio Plugin communicate through abstract socket name
+"\0bluez_sco_socket".
+
+	.----SCO----.                             .--Android--.
+	|   Plugin  |                             |   Daemon  |
+	|           |          Command            |           |
+	|           | --------------------------> |           |
+	|           |                             |           |
+	|           | <-------------------------- |           |
+	|           |          Response           |           |
+	|           |                             |           |
+	|           |                             |           |
+	|           |                             |           |
+	'-----------'                             '-----------'
+
+
+	SCO HAL                               Daemon
+	----------------------------------------------------
+
+	call get_fd()                    --> Get SCO socket fd
+	return get_fd()                  <-- Return SCO socket fd and mtu
+
+SCO Audio Service (ID 0)
+========================
+
+	Opcode 0x00 - Error response
+
+		Response parameters: Status (1 octet)
+
+	Opcode 0x01 - Get SCO fd command
+
+		Command parameters: Remote address (6 octets)
+		Response parameters: MTU (2 octets)
+				     File descriptor (inline)
--- /dev/null
+++ ppa/android/socket-api.txt
@@ -0,0 +1,61 @@
+Android Socket protocol for Bluetooth
+=====================================
+
+Since Android switched from BlueZ (where sockets where nicely implemented) to
+Bluedroid user space stack there is a need to emulate bluetooth sockets.
+
+Android Bluetooth Socket Hardware Abstraction Layer (HAL) bt_sock.h has
+only 2 functions:
+
+static btsock_interface_t sock_if = {
+	sizeof(sock_if),
+	sock_listen,
+	sock_connect
+};
+
+with following parameters:
+
+sock_listen(btsock_type_t type, const char *service_name,
+		const uint8_t *uuid, int chan, int *sock_fd, int flags)
+sock_connect(const bt_bdaddr_t *bdaddr, btsock_type_t type,
+		const uint8_t *uuid, int chan, int *sock_fd, int flags)
+
+socket type RFCOMM is only supported at the moment. uuid and channel used
+to decide where to connect.
+
+sockfd is used to return socket fd to Android framework. It is used to inform
+framework when remote device is connected.
+
+listen()
+========
+
+Listens on RFCOMM socket, socket channel is either found based on uuid or
+channel parameter used directly. Returns sock_fd to Android framework.
+
+Through this sock_fd channel number as (int) needs to be written right after
+listen() succeeds.
+
+When remote device is connected to this socket we shall send accept signal
+through sock_fd
+
+connect()
+=========
+
+Connects to remote device specified in bd_addr parameter. Socket channel is
+found by SDP search of remote device by supplied uuid. Returns sock_fd to
+Android framework.
+
+Through this sock_fd channel number as (int) needs to be written right after
+connects() succeeds.
+
+When remote device is connected to this socket we shall send connect signal
+through sock_fd
+
+The format of connect/accept signal is shown below:
+
+struct hal_sock_connect_signal {
+	short   size;
+	uint8_t bdaddr[6];
+	int     channel;
+	int     status;
+} __attribute__((packed));
--- /dev/null
+++ ppa/bootstrap
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+aclocal && \
+    autoheader && \
+	libtoolize --automake --copy --force && \
+	    automake --add-missing --copy && \
+		autoconf
--- /dev/null
+++ ppa/bootstrap-configure
@@ -0,0 +1,37 @@
+#!/bin/sh
+
+if [ -f config.status ]; then
+	make maintainer-clean
+fi
+
+./bootstrap && \
+    ./configure --enable-maintainer-mode \
+		--enable-debug \
+		--prefix=/usr \
+		--mandir=/usr/share/man \
+		--sysconfdir=/etc \
+		--localstatedir=/var \
+		--enable-tools \
+		--enable-manpages \
+		--enable-backtrace \
+		--enable-testing \
+		--enable-experimental \
+		--enable-deprecated \
+		--enable-nfc \
+		--enable-sap \
+		--enable-health \
+		--enable-android \
+		--enable-sixaxis \
+		--enable-hid2hci \
+		--enable-midi \
+		--enable-mesh \
+		--enable-btpclient \
+		--enable-logger \
+		--enable-pie \
+		--enable-asan \
+		--enable-lsan \
+		--enable-ubsan \
+		--enable-cups \
+		--enable-library \
+		--enable-admin \
+		--disable-datafiles $*
--- /dev/null
+++ ppa/client/scripts/advertise-broadcast.bt
@@ -0,0 +1,2 @@
+power on
+advertise broadcast
--- /dev/null
+++ ppa/client/scripts/advertise-on.bt
@@ -0,0 +1,2 @@
+power on
+advertise on
--- /dev/null
+++ ppa/client/scripts/advertise-peripheral.bt
@@ -0,0 +1,2 @@
+power on
+advertise peripheral
--- /dev/null
+++ ppa/client/scripts/gatt-batt.bt
@@ -0,0 +1,5 @@
+gatt.register-service 0x180f
+yes
+gatt.register-characteristic 0x2a19 read,notify
+64
+gatt.register-application
--- /dev/null
+++ ppa/client/scripts/power-on-off.bt
@@ -0,0 +1,3 @@
+power on
+power off
+quit
--- /dev/null
+++ ppa/client/scripts/power-on.bt
@@ -0,0 +1,3 @@
+power on
+show
+quit
--- /dev/null
+++ ppa/client/scripts/preset-custom.bt
@@ -0,0 +1,26 @@
+endpoint.presets 00002bc9-0000-1000-8000-00805f9b34fb custom
+48
+10
+3
+100
+Low
+10000
+Unframed
+2M
+200
+3
+10
+20000
+endpoint.presets 00002bcb-0000-1000-8000-00805f9b34fb custom
+48
+10
+3
+100
+Low
+10000
+Unframed
+2M
+200
+3
+10
+20000
--- /dev/null
+++ ppa/client/scripts/scan-bredr.bt
@@ -0,0 +1,2 @@
+power on
+scan bredr
--- /dev/null
+++ ppa/client/scripts/scan-le.bt
@@ -0,0 +1,2 @@
+power on
+scan le
--- /dev/null
+++ ppa/client/scripts/scan-on-off.bt
@@ -0,0 +1,4 @@
+scan on
+show
+scan off
+quit
--- /dev/null
+++ ppa/client/scripts/scan-on.bt
@@ -0,0 +1,2 @@
+power on
+scan on
--- /dev/null
+++ ppa/doc/ci.config
@@ -0,0 +1,122 @@
+#############################################################
+#                                                           #
+#   This config file is for testing bluetooth build only.   #
+#                                                           #
+#############################################################
+
+CONFIG_VIRTIO=y
+CONFIG_VIRTIO_PCI=y
+
+CONFIG_NET=y
+CONFIG_INET=y
+
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+
+CONFIG_9P_FS=y
+CONFIG_9P_FS_POSIX_ACL=y
+
+CONFIG_GPIOLIB=y
+
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+
+CONFIG_SERIAL_DEV_BUS=y
+
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+
+CONFIG_DEVTMPFS=y
+CONFIG_DEBUG_FS=y
+
+CONFIG_MMC=y
+
+CONFIG_RPMSG=y
+CONFIG_QCOM_WCNSS_CTRL=y
+
+CONFIG_PCMCIA=y
+
+CONFIG_ISDN_CAPI=y
+
+CONFIG_6LOWPAN=y
+
+CONFIG_LEDS_CLASS=y
+
+CONFIG_USB=y
+
+CONFIG_BT=y
+CONFIG_BT_BREDR=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_LE=y
+CONFIG_BT_MSFTEXT=y
+CONFIG_BT_HS=y
+CONFIG_BT_CMTP=y
+CONFIG_BT_6LOWPAN=y
+CONFIG_BT_LEDS=y
+CONFIG_BT_FEATURE_DEBUG=y
+
+CONFIG_BT_HCIVHCI=y
+
+CONFIG_BT_HCIBTUSB=y
+CONFIG_BT_HCIBTUSB_AUTOSUSPEND=y
+CONFIG_BT_HCIBTUSB_MTK=y
+CONFIG_BT_HCIBCM203X=y
+CONFIG_BT_HCIBPA10X=y
+CONFIG_BT_MRVL=y
+CONFIG_BT_ATH3K=y
+
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_SERDEV=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIUART_ATH3K=y
+CONFIG_BT_HCIUART_AG6XX=y
+CONFIG_BT_HCIUART_NOKIA=y
+CONFIG_BT_HCIUART_LL=y
+CONFIG_BT_HCIUART_3WIRE=y
+CONFIG_BT_HCIUART_INTEL=y
+CONFIG_BT_HCIUART_BCM=y
+CONFIG_BT_HCIUART_RTL=y
+CONFIG_BT_HCIUART_QCA=y
+CONFIG_BT_HCIUART_MRVL=y
+CONFIG_BT_MTKUART=y
+
+CONFIG_BT_HCIBFUSB=y
+
+CONFIG_BT_HCIBTSDIO=y
+CONFIG_BT_MRVL_SDIO=y
+CONFIG_BT_MTKSDIO=y
+
+CONFIG_BT_HCIDTL1=y
+CONFIG_BT_HCIBT3C=y
+CONFIG_BT_HCIBLUECARD=y
+
+CONFIG_BT_QCOMSMD=y
+
+CONFIG_BT_VIRTIO=y
+
+CONFIG_CRYPTO_CMAC=y
+CONFIG_CRYPTO_USER_API=y
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
+
+CONFIG_UNIX=y
+
+CONFIG_UHID=y
+
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_LOCK_ALLOC=y
+CONFIG_PROVE_LOCKING=y
+CONFIG_LOCKDEP=y
+CONFIG_DEBUG_MUTEXES=y
+
+CONFIG_OF=y
--- /dev/null
+++ ppa/doc/coding-style.txt
@@ -0,0 +1,279 @@
+BlueZ coding style
+******************
+
+Every project has its coding style, and BlueZ is not an exception. This
+document describes the preferred coding style for BlueZ code, in order to keep
+some level of consistency among developers so that code can be easily
+understood and maintained.
+
+First of all, BlueZ coding style must follow every rule for Linux kernel
+(https://www.kernel.org/doc/Documentation/process/coding-style.rst). There also
+exists a tool named checkpatch.pl to help you check the compliance with it.
+Just type "checkpatch.pl --no-tree patch_name" to check your patch. In theory,
+you need to clean up all the warnings and errors except this one: "ERROR:
+Missing Signed-off-by: line(s)". BlueZ does not used Signed-Off lines, so
+including them is actually an error.  In certain circumstances one can ignore
+the 80 character per line limit.  This is generally only allowed if the
+alternative would make the code even less readable.
+
+Besides the kernel coding style above, BlueZ has special flavors for its own.
+Some of them are mandatory (marked as 'M'), while some others are optional
+(marked as 'O'), but generally preferred.
+
+M1: Blank line before and after an if/while/do/for statement
+============================================================
+
+There should be a blank line before if statement unless the if is nested and
+not preceded by an expression or variable declaration.
+
+Example:
+1)
+a = 1;
+if (b) {  // wrong
+
+2)
+a = 1
+
+if (b) {
+}
+a = 2;	// wrong
+
+3)
+if (a) {
+	if (b)  // correct
+
+4)
+b = 2;
+
+if (a) {	// correct
+
+}
+
+b = 3;
+
+The only exception to this rule applies when a variable is being checked for
+errors as such:
+
+err = stat(filename, &st);
+if (err || !S_ISDIR(st.st_mode))
+	return;
+
+M2: Multiple line comment
+=========================
+
+If your comment has more than one line, please start it from the second line.
+
+Example:
+/*
+ * first line comment	// correct
+ * ...
+ * last line comment
+ */
+
+
+M3: Space before and after operator
+===================================
+
+There should be a space before and after each operator.
+
+Example:
+a + b;  // correct
+
+
+M4: Wrap long lines
+===================
+
+If your condition in if, while, for statement or a function declaration is too
+long to fit in one line, the new line needs to be indented not aligned with the
+body.
+
+Example:
+1)
+if ((adapter->supported_settings & MGMT_SETTING_SSP) &&
+	!(adapter->current_settings & MGMT_SETTING_SSP)) // wrong
+
+2)
+if ((adapter->supported_settings & MGMT_SETTING_SSP) &&
+				!(adapter->current_settings & MGMT_SETTING_SSP))
+
+3)
+void btd_adapter_register_pin_cb(struct btd_adapter *adapter,
+				 btd_adapter_pin_cb_t cb) // wrong
+
+4)
+void btd_adapter_register_pin_cb(struct btd_adapter *adapter,
+							btd_adapter_pin_cb_t cb)
+
+The referred style for line wrapping is to indent as far as possible to the
+right without hitting the 80 columns limit.
+
+M5: Space when doing type casting
+=================================
+
+There should be a space between new type and variable.
+
+Example:
+1)
+a = (int *)b;  // wrong
+2)
+a = (int *) b;  // correct
+
+
+M6: Don't initialize variable unnecessarily
+===========================================
+
+When declaring a variable, try not to initialize it unless necessary.
+
+Example:
+int i = 1;  // wrong
+
+for (i = 0; i < 3; i++) {
+}
+
+M7: Follow the order of include header elements
+===============================================
+
+When writing an include header the various elements should be in the following
+order:
+	- #includes
+	- forward declarations
+	- #defines
+	- enums
+	- typedefs
+	- function declarations and inline function definitions
+
+M8: Internal headers must not use include guards
+================================================
+
+Any time when creating a new header file with non-public API, that header
+must not contain include guards.
+
+M9: Naming of enums
+===================
+
+Enums must have a descriptive name.  The enum type should be small caps and
+it should not be typedef-ed.  Enum contents should be in CAPITAL letters and
+prefixed by the enum type name.
+
+Example:
+
+enum animal_type {
+	ANIMAL_TYPE_FOUR_LEGS,
+	ANIMAL_TYPE_EIGHT_LEGS,
+	ANIMAL_TYPE_TWO_LEGS,
+};
+
+If the enum contents have values (e.g. from specification) the formatting
+should be as follows:
+
+enum animal_type {
+	ANIMAL_TYPE_FOUR_LEGS =		4,
+	ANIMAL_TYPE_EIGHT_LEGS =	8,
+	ANIMAL_TYPE_TWO_LEGS =		2,
+};
+
+M10: Enum as switch variable
+============================
+
+If the variable of a switch is an enum, you must include all values in
+switch body even if providing default. This is enforced by compiler option
+enabling extra warning in such case. The reason for this is to ensure that if
+later on enum is modified and one forget to change the switch accordingly, the
+compiler will complain the new added type hasn't been handled.
+
+Example:
+
+enum animal_type {
+	ANIMAL_TYPE_FOUR_LEGS =		4,
+	ANIMAL_TYPE_EIGHT_LEGS =	8,
+	ANIMAL_TYPE_TWO_LEGS =		2,
+};
+
+enum animal_type t;
+
+switch (t) { // OK
+case ANIMAL_TYPE_FOUR_LEGS:
+	...
+	break;
+case ANIMAL_TYPE_EIGHT_LEGS:
+	...
+	break;
+case ANIMAL_TYPE_TWO_LEGS:
+	...
+	break;
+default:
+	break;
+}
+
+switch (t) { // Wrong
+case ANIMAL_TYPE_FOUR_LEGS:
+	...
+	break;
+case ANIMAL_TYPE_TWO_LEGS:
+	...
+	break;
+default:
+	break;
+}
+
+However if the enum comes from an external header file outside BlueZ, such as
+Android headers, we cannot make any assumption of how the enum is defined and
+this rule might not apply.
+
+M11: Always use parenthesis with sizeof
+=======================================
+
+The expression argument to the sizeof operator should always be in
+parenthesis, too.
+
+Example:
+1)
+memset(stuff, 0, sizeof(*stuff));
+
+2)
+memset(stuff, 0, sizeof *stuff); // Wrong
+
+M12: Use void if function has no parameters
+===========================================
+
+A function with no parameters must use void in the parameter list.
+
+Example:
+1)
+void foo(void)
+{
+}
+
+2)
+void foo()	// Wrong
+{
+}
+
+O1: Try to avoid complex if body
+================================
+
+It's better not to have a complicated statement for if. You may judge its
+contrary condition and return | break | continue | goto ASAP.
+
+Example:
+1)
+if (device) {  // worse
+	memset(&eir_data, 0, sizeof(eir_data));
+	if (eir_len > 0)
+		eir_parse(&eir_data, ev->eir, eir_len);
+	...
+} else {
+	error("Unable to get device object for %s", addr);
+	return;
+}
+
+2)
+if (!device) {
+	error("Unable to get device object for %s", addr);
+	return;
+}
+
+memset(&eir_data, 0, sizeof(eir_data));
+if (eir_len > 0)
+	eir_parse(&eir_data, ev->eir, eir_len);
+...
--- /dev/null
+++ ppa/doc/errors.txt
@@ -0,0 +1,233 @@
+D-Bus Method Return Error Codes
+===============================
+
+The motivation of having detailed error is to provide context-based failure
+reasons along with D-Bus method return so that D-Bus clients can build metrics
+and optimize their application based on these failure reasons. For instance, a
+client can build retry mechanism for a connection failure or improve the
+bottleneck of use scenario based on actionable metrics.
+
+These error codes are context-based but not necessarily tied to interface or
+method calls. For instance, if a pairing request failed due to connection
+failure, connection error would be attached to the method return of Pair().
+
+BR/EDR connection already connected
+===================================
+	errno:	EALREADY, EISCONN
+
+	Either the profile is already connected or ACL connection is in place.
+
+BR/EDR connection page timeout
+==============================
+	errno:	EHOSTDOWN
+
+	Failed due to page timeout.
+
+BR/EDR connection profile unavailable
+=====================================
+	errno:	ENOPROTOOPT
+
+	Failed to find connectable services or the target service.
+
+BR/EDR connection SDP search
+============================
+	errno:	none
+
+	Failed to complete the SDP search.
+
+BR/EDR connection create socket
+===============================
+	errno:	EIO
+
+	Failed to create or connect to BT IO socket. This can also indicate
+	hardware failure in the controller.
+
+BR/EDR connection invalid arguments
+===================================
+	errno:	EHOSTUNREACH
+
+	Failed due to invalid arguments.
+
+BR/EDR connection not powered
+=============================
+	errno:	EHOSTUNREACH
+
+	Failed due to adapter not powered.
+
+BR/EDR connection not supported
+===============================
+	errno:	EOPNOTSUPP, EPROTONOSUPPORT
+
+	Failed due to unsupported state transition of L2CAP channel or other
+	features either by the local host or the remote.
+
+BR/EDR connection bad socket
+============================
+	errno:	EBADFD
+
+	Failed due to the socket is in bad state.
+
+BR/EDR connection memory allocation
+===================================
+	errno:	ENOMEM
+
+	Failed to allocate memory in either host stack or controller.
+
+BR/EDR connection busy
+======================
+	errno:	EBUSY
+
+	Failed due to other ongoing operations, such as pairing, busy L2CAP
+	channel or the operation disallowed by the controller.
+
+BR/EDR connection concurrent connection limit
+=============================================
+	errno:	EMLINK
+
+	Failed due to reaching the concurrent connection limit to a device.
+
+BR/EDR connection timeout
+=========================
+	errno:	ETIMEDOUT
+
+	Failed due to connection timeout
+
+BR/EDR connection refused
+=========================
+	errno:	ECONNREFUSED
+
+	Refused by the remote device due to limited resource, security reason
+	or unacceptable address type.
+
+BR/EDR connection aborted by remote
+===================================
+	errno:	ECONNRESET
+
+	Terminated by the remote device due to limited resource or power off.
+
+BR/EDR connection aborted by local
+==================================
+	errno:	ECONNABORTED
+
+	Aborted by the local host.
+
+BR/EDR connection LMP protocol error
+====================================
+	errno:	EPROTO
+
+	Failed due to LMP protocol error.
+
+BR/EDR connection canceled
+==========================
+	errno:	none
+
+	Failed due to cancellation caused by adapter drop, unexpected device
+	drop, orincoming disconnection request before connection request is
+	completed.
+
+BR/EDR connection unknown error
+===============================
+	errno:	ENOSYS
+
+	Failed due to unknown reason.
+
+LE connection invalid arguments
+===============================
+	errno:	EINVAL
+
+	Failed due to invalid arguments.
+
+LE connection not powered
+=========================
+	errno:	EHOSTUNREACH
+
+	Failed due to adapter not powered.
+
+LE connection not supported
+===========================
+	errno:	EOPNOTSUPP, EPROTONOSUPPORT
+
+	Failed due to unsupported state transition of L2CAP channel or other
+	features (e.g. LE features) either by the local host or the remote.
+
+LE connection already connected
+===============================
+	errno: EALREADY, EISCONN
+
+	Either the BT IO is already connected or LE link connection in place.
+
+LE connection bad socket
+========================
+	errno: EBADFD
+
+	Failed due to the socket is in bad state.
+
+LE connection memory allocation
+===============================
+	errno: ENOMEM
+
+	Failed to allocate memory in either host stack or controller.
+
+LE connection busy
+==================
+	errno:	EBUSY
+
+	Failed due to other ongoing operations, such as pairing, connecting,
+	busy L2CAP channel or the operation disallowed by the controller.
+
+LE connection refused
+=====================
+	errno:	ECONNREFUSED
+
+	Failed due to that LE is not enabled or the attempt is refused by the
+	remote device due to limited resource, security reason or unacceptable
+	address type.
+
+LE connection create socket
+===========================
+	errno:	EIO
+
+	Failed to create or connect to BT IO socket. This can also indicate
+	hardware failure in the controller.
+
+LE connection timeout
+=====================
+	errno:	ETIMEDOUT
+
+	Failed due to connection timeout
+
+LE connection concurrent connection limit
+=========================================
+	errno:	EMLINK
+
+	Failed due to reaching the synchronous connection limit to a device.
+
+LE connection abort by remote
+=============================
+	errno:	ECONNRESET
+
+	Aborted by the remote device due to limited resource or power off.
+
+LE connection abort by local
+============================
+	errno:	ECONNABORTED
+
+	Aborted by the local host.
+
+LE connection link layer protocol error
+=======================================
+	errno:	EPROTO
+
+	Failed due to link layer protocol error.
+
+LE connection GATT browsing
+===========================
+	errno:	none
+
+	Failed to complete the GATT browsing.
+
+LE connection unknown error
+===========================
+	errno:	ENOSYS
+
+	Failed due to unknown reason.
--- /dev/null
+++ ppa/doc/intel-variants.txt
@@ -0,0 +1,159 @@
+Intel Hardware Varaints
+=======================
+
+These are the list of Intel Bluetooth devices and its information.
+
+Some of devices were tested the following test cases:
+	Firmware loading after cold boot
+	Firmware loading after restart
+	Device discovery
+	Connection to LE Mouse
+	A2DP
+	HFP
+	Update to new firmware if available
+
+All Intel firmware can be found from linux-firmware git repo.
+https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git
+
+
+Device List
+-----------
+
+Wilkins Peak (WP)
+- HW ID:	USB(0x8087:0x07dc)
+- Device Type:	Legacy ROM device
+- Driver flag:	BTUSB_INTEL_BROKEN_INITIAL_NCMD
+- HW variant:	0x07
+- FW files:
+	WP2 B3
+	intel/ibt-hw-37.7.10-fw-1.80.2.3.d.bseq
+		tested: Patch Version: 87    Release Version: 20.60.0.2
+			70353356f ("linux-firmware: Update firmware patch for Intel Bluetooth 7260 (B3/B4)")
+	WP2 B5
+	intel/ibt-hw-37.7.10-fw-1.80.1.2d.d.bseq
+		tested: Patch Version: 42    Release Version: 20.60.0.2
+			629a5e089 ("linux-firmware: Update firmware patch for Intel Bluetooth 7260 (B5/B6)")
+
+	WP1 B3
+	intel/ibt-hw-37.7.10-fw-1.0.1.2d.d.bseq
+
+	WP1 B3
+	intel/ibt-hw-37.7.10-fw-1.0.2.3.d.bseq
+
+
+Stone Peak (StP)
+- HW ID:	USB(0x8087:0x0a2a)
+- Device Type:	Legacy ROM device
+- HW variant:	0x08
+- FW files:
+	StP
+	intel/ibt-hw-37.8.10-fw-1.10.2.27.d.bseq
+
+	StP D1
+	intel/ibt-hw-37.8.10-fw-1.10.3.11.e.bseq
+		tested: FW Build: REL_50_0002    Release Version: 20.60.0.2
+			9489f5524 ("linux-firmware: Update firmware patch for Intel Bluetooth 7265 (D0)")
+
+
+Sandy Peak (SdP)
+- HW ID:	USB(0x8087:0x0aa7)
+- Device Type:	Legacy ROM device
+- HCI Quirks:	HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED
+- HW variant:	0x08
+	intel/ibt-hw-37.8.10-fw-22.50.19.14.f.bseq
+		tested: FW Patch Version: 0x42(66)
+			195ecf149 ("linux-firmware: Intel BT 7265: Fix Security Issues")
+
+
+Snow Field Peak (SfP) / Windstorm Peak (WsP)
+- HW ID:	USB(0x8087:0x0a2b)
+- Device Type:	Legacy Bootloader device
+- HCI Quirks:	HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED
+- HW variant:	0x0b
+	SfP
+	intel/ibt-11-5.sfi
+		tested: FW Build: REL0522    Release Version: 20.100.0.3
+			f0896585b ("linux-firmware: Update firmware patch for Intel Bluetooth 8260")
+- HW variant:	0x0c
+	WsP
+	intel/ibt-12-16.sfi
+		tested: FW Build: REL1221    Release Version: 22.50.0.4
+			4116d72b9 ("linux-firmware: Update firmware file for Intel Bluetooth 8265")
+		tested: FW Build: REL0306    Release Version: 21.10.0.6
+			1f8ebdfc2 ("linux-firmware: Update firmware file for Intel Bluetooth 8265")
+
+
+Jefferson Peak (JfP)
+- HW ID:	USB(0x8087:0x0aaa)
+- Device Type:	Legacy Bootloader device
+- HCI Quirks:	HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED
+		HCI_QUIRK_VALID_LE_STATES
+- HW variant:	0x11
+	intel/ibt-17-0-1.sfi
+	intel/ibt-17-16-1.sfi
+
+
+Thunder Peak (ThP)
+- HW ID:	USB(0x8087:0x0025)
+- Device Type:	Legacy Bootloader device
+- HCI Quirks:	HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED
+		HCI_QUIRK_VALID_LE_STATES
+- HW variant:	0x12
+	intel/ibt-18-0-1.sfi
+	intel/ibt-18-16-1.sfi
+		tested: FW Build: REL19718    Release Version: 22.50.0.4
+			687d64a4d ("linux-firmware: Update firmware file for Intel Bluetooth 9260")
+		tested: FW Build: REL13313    Release Version: 21.120.0.4
+			db3038082 ("linux-firmware: Update firmware file for Intel Bluetooth 9260")
+
+
+Quasar(QsR) / Harrison Peak (HrP)
+- HW ID:	USB(0x8087:0x0026)
+- Device Type:	Legacy Bootloader device
+- HCI Quirks:	HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED
+- HW variant: 	0x13
+	Quasar with JfP
+	intel/ibt-19-0-1.sfi
+	intel/ibt-19-240-1.sfi
+
+	Quasar with HrP
+	intel/ibt-19-0-4.sfi
+	intel/ibt-19-240-4.sfi
+
+	intel/ibt-19-0-0.sfi
+	intel/ibt-19-16-4.sfi
+	intel/ibt-19-32-0.sfi
+	intel/ibt-19-32-1.sfi
+	intel/ibt-19-32-4.sfi
+
+
+Cyclone Peak (CcP)
+- HW ID:	USB(0x8087:0x0029)
+- Device Type:	Legacy Bootloader device
+- HCI Quirks:	HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED
+- HW variant:	0x14
+	intel/ibt-20-0-3.sfi
+	intel/ibt-20-1-3.sfi
+		tested: FW Build: REL25791    Release Version: 22.60.0.3
+			34803c20f ("linux-firmware: Update firmware file for Intel Bluetooth AX200")
+	intel/ibt-20-1-4.sfi
+
+
+Typhon Peak (TyP)
+- HW ID:	USB(0x8087:0x0032)
+- Device Type:	TLV based Bootloader device
+- HCI Quirks:	HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED
+- HW variant:	0x17
+	intel/ibt-0041-0041.sfi
+		tested: FW Build: REL25171    Release Version: 22.60.0.3
+			25ddc612f ("linux-firmware: Update firmware file for Intel Bluetooth AX210")
+		tested: FW Build: REL17510    Release Version: 22.20.0.3
+			28185ecdc ("linux-firmware: Update firmware file for Intel Bluetooth AX210")
+
+
+Garfield Peak (GfP)
+- HW ID:	USB(0x8087:0x0033)
+- Device Type:	TLV based Bootloader device
+- HCI Quirks:	HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED
+		HCI_QUIRK_VALID_LE_STATES
+- HW variant:	0x18
--- /dev/null
+++ ppa/doc/maintainer-guidelines.txt
@@ -0,0 +1,114 @@
+Maintainer guidelines
+*********************
+
+This document is intended for the maintainers of the BlueZ project. It
+serves as basic guidelines for handling patch review and commit access.
+
+
+Rule 1: Keep the GIT tree clean and linear
+==========================================
+
+The bluetooth.git, bluetooth-next.git and bluez.git trees are not your
+private playground. The history is meant to be clean and linear.
+
+	- NO merges
+	- NO branches
+	- NO tags
+
+If anyone needs testing or work on a feature, clone the tree and do
+it in your own copy. The master trees are off limits.
+
+One advise to avoid any accidental errors in this area to set proper
+options in global ~/.gitconfig or local .git/config files.
+
+	[merge]
+		ff = only
+
+Violations of this rule are not acceptable. This rule is enforced. If
+in doubt ask one of the seasoned maintainers.
+
+
+Rule 2: Enforce clean commit messages
+=====================================
+
+The commit messages are required to be clean and follow style guidelines
+to be consistent.
+
+Commit messages should adhere to a 72 characters by line limit. That
+makes it easy to read them via git log in a terminal window. Exceptions
+to this rule are logs, trace or other verbatim copied information.
+
+Every commit requires full names and email addresses. No synonyms or
+nicknames are allowed. It is also important that the Outlook style
+names with lastname, firstname are not allowed. It is the maintainers
+job to ensure we get proper firstname lastname <email> authorship.
+
+It is also important that the committer itself uses a valid name and
+email address when committing patches. So ensure that either the
+global ~/.gitconfig or local .git/config provides proper values.
+
+	[user]
+		name = Peter Mustermann
+		email = peter@mustermann.de
+
+Commit messages for bluez.git shall not contain Signed-off-by
+signatures. They are not used in userspace and with that it is the
+maintainers job to ensure they do not get committed to the repository.
+
+For bluetooth.git and bluetooth-next.git The Signed-off-by process is
+used and the signatures are required.
+
+Tags like Change-Id generated from Gerrit are never acceptable. It is
+the maintainers job to ensure that these are not committed into the
+repositories.
+
+Violations of this rule create a mess in the tree that can not be
+reversed. If in doubt ask one of the seasoned maintainers.
+
+
+Rule 3: Enforce correct coding style
+====================================
+
+The coding style follows roughly the kernel coding style with any
+exceptions documented in doc/coding-style.txt.
+
+To ensure trivial white-space errors don't get committed, have the
+following in your .gitconfig:
+
+	[apply]
+		whitespace = error
+
+It can also be helpful to use the checkpatch.pl script coming with the
+Linux kernel to do some automated checking. Adding the following to your
+.git/hooks/pre-commit and .git/hooks/pre-applypatch is a simple way to
+do this:
+
+	exec git diff --cached | ~/src/linux/scripts/checkpatch.pl -q \
+		--no-tree --no-signoff --show-types \
+		--ignore CAMELCASE,NEW_TYPEDEFS,INITIALISED_STATIC -
+
+The above assumes that a kernel tree resides in ~/src/linux/.
+
+
+Rule 4: Pay extra attention to adding new files to the tree
+===========================================================
+
+New files that are added to the tree require several things to be
+verified first:
+
+	- Check that the names are acceptible with other maintainers
+	- Ensure that the file modes are correct
+	- Verify that the license & copyright headers are correct
+	- If the file is supposed to be part of the release tarball,
+	  make sure that it gets picked up by 'make dist' (particularly
+	  important for documentation or other files that are not code)
+
+
+Rule 5: Keep the mailing list in sync with the commit process
+=============================================================
+
+When applying patches, be sure to send a response to the mailing list as
+soon as the code has been pushed to the upstream tree. Usually this
+means one email per patch, however patch-sets may only have one response
+covering the entire set. If applying a subset of a patch-set clearly
+state what was applied in your response.
--- /dev/null
+++ ppa/doc/mesh-api.txt
@@ -0,0 +1,1375 @@
+BlueZ D-Bus Mesh API description
+********************************
+
+Mesh Network Hierarchy
+======================
+Service		org.bluez.mesh
+Interface	org.bluez.mesh.Network1
+Object path	/org/bluez/mesh
+
+Methods:
+	void Join(object app_root, array{byte}[16] uuid)
+
+		This is the first method that an application has to call to
+		become a provisioned node on a mesh network. The call will
+		initiate broadcasting of Unprovisioned Device Beacon.
+
+		The app_root parameter is a D-Bus object root path of
+		the application that implements org.bluez.mesh.Application1
+		interface. The application represents a node where child mesh
+		elements have their own objects that implement
+		org.bluez.mesh.Element1 interface. The application hierarchy
+		also contains a provision agent object that implements
+		org.bluez.mesh.ProvisionAgent1 interface. The standard
+		DBus.ObjectManager interface must be available on the
+		app_root path.
+
+		The uuid parameter is a 16-byte array that contains Device UUID.
+		This UUID must be unique (at least from the daemon perspective),
+		therefore attempting to call this function using already
+		registered UUID results in an error. The composition of the UUID
+		octets must be in compliance with RFC 4122.
+
+		When provisioning finishes, the daemon will call either
+		JoinComplete or JoinFailed method on object implementing
+		org.bluez.mesh.Application1 interface.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.InvalidArguments
+			org.bluez.mesh.Error.AlreadyExists,
+
+	void Cancel(void)
+
+		Cancels an outstanding provisioning request initiated by Join()
+		method.
+
+	object node, array{byte, array{(uint16, dict)}} configuration
+			Attach(object app_root, uint64 token)
+
+		This is the first method that an application must call to get
+		access to mesh node functionalities.
+
+		The app_root parameter is a D-Bus object root path of
+		the application that implements org.bluez.mesh.Application1
+		interface. The application represents a node where child mesh
+		elements have their own objects that implement
+		org.bluez.mesh.Element1 interface. The standard
+		DBus.ObjectManager interface must be available on the
+		app_root path.
+
+		The token parameter is a 64-bit number that has been assigned to
+		the application when it first got provisioned/joined mesh
+		network, i.e. upon receiving JoinComplete() method. The daemon
+		uses the token to verify whether the application is authorized
+		to assume the mesh node identity.
+
+		In case of success, the method call returns mesh node object
+		(see Mesh Node Hierarchy section) and current configuration
+		settings. The return value of configuration parameter is an
+		array, where each entry is a structure that contains element
+		configuration. The element configuration structure is organized
+		as follows:
+
+		byte
+
+			Element index, identifies the element to which this
+			configuration entry pertains.
+
+		array{struct}
+
+			Models array where each entry is a structure with the
+			following members:
+
+			uint16
+
+				Either a SIG Model Identifier or, if Vendor key
+				is present in model configuration dictionary, a
+				16-bit vendor-assigned Model Identifier
+
+			dict
+
+				A dictionary that contains model configuration
+				with the following keys defined:
+
+				array{uint16} Bindings
+
+					Indices of application keys bound to the
+					model
+
+				uint32 PublicationPeriod
+
+					Model publication period in milliseconds
+
+				uint16 Vendor
+
+					A 16-bit Company ID as defined by the
+					Bluetooth SIG
+
+				array{variant} Subscriptions
+
+					Addresses the model is subscribed to.
+
+					Each address is provided either as
+					uint16 for group addresses, or
+					as array{byte} for virtual labels.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.InvalidArguments
+			org.bluez.mesh.Error.NotFound,
+			org.bluez.mesh.Error.AlreadyExists,
+			org.bluez.mesh.Error.Busy,
+			org.bluez.mesh.Error.Failed
+
+	void Leave(uint64 token)
+
+		This removes the configuration information about the mesh node
+		identified by the 64-bit token parameter. The token parameter
+		has been obtained as a result of successful Join() method call.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.InvalidArguments
+			org.bluez.mesh.Error.NotFound
+			org.bluez.mesh.Error.Busy
+
+	void CreateNetwork(object app_root, array{byte}[16] uuid)
+
+		This is the first method that an application calls to become
+		a Provisioner node, and a Configuration Client on a newly
+		created Mesh Network.
+
+		The app_root parameter is a D-Bus object root path of the
+		application that implements org.bluez.mesh.Application1
+		interface, and a org.bluez.mesh.Provisioner1 interface. The
+		application represents a node where child mesh elements have
+		their own objects that implement org.bluez.mesh.Element1
+		interface. The application hierarchy also contains a provision
+		agent object that implements org.bluez.mesh.ProvisionAgent1
+		interface. The standard DBus.ObjectManager interface must be
+		available on the app_root path.
+
+		The uuid parameter is a 16-byte array that contains Device UUID.
+		This UUID must be unique (at least from the daemon perspective),
+		therefore attempting to call this function using already
+		registered UUID results in an error. The composition of the UUID
+		octets must be in compliance with RFC 4122.
+
+		The other information the bluetooth-meshd daemon will preserve
+		about the initial node, is to give it the initial primary
+		unicast address (0x0001), and create and assign a net_key as the
+		primary network net_index (0x000).
+
+		Upon successful processing of Create() method, the daemon
+		will call JoinComplete method on object implementing
+		org.bluez.mesh.Application1.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.InvalidArguments
+			org.bluez.mesh.Error.AlreadyExists,
+
+	void Import(object app_root, array{byte}[16] uuid,
+				array{byte}[16] dev_key,
+				array{byte}[16] net_key, uint16 net_index,
+				dict flags, uint32 iv_index, uint16 unicast)
+
+		This method creates a local mesh node based on node
+		configuration that has been generated outside bluetooth-meshd.
+
+		The app_root parameter is a D-Bus object root path of the
+		application that implements org.bluez.mesh.Application1
+		interface.
+
+		The uuid parameter is a 16-byte array that contains Device UUID.
+		This UUID must be unique (at least from the daemon perspective),
+		therefore attempting to call this function using already
+		registered UUID results in an error. The composition of the UUID
+		octets must be in compliance with RFC 4122.
+
+		The dev_key parameter is the 16-byte value of the dev key of
+		the imported mesh node.
+
+		Remaining parameters correspond to provisioning data:
+
+		The net_key and net_index parameters describe the network (or a
+		subnet, if net_index is not 0) the imported mesh node belongs
+		to.
+
+		The flags parameter is a dictionary containing provisioning
+		flags. Supported values are:
+
+			boolean IvUpdate
+
+				When true, indicates that the network is in the
+				middle of IV Index Update procedure.
+
+			boolean KeyRefresh
+
+				When true, indicates that the specified net key
+				is in the middle of a key refresh procedure.
+
+		The iv_index parameter is the current IV Index value used by
+		the network. This value is known by the provisioner.
+
+		The unicast parameter is the primary unicast address of the
+		imported node.
+
+		Upon successful processing of Import() method, the daemon will
+		call JoinComplete method on object implementing
+		org.bluez.mesh.Application1 interface.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.InvalidArguments,
+			org.bluez.mesh.Error.AlreadyExists,
+			org.bluez.mesh.Error.NotSupported,
+			org.bluez.mesh.Error.Failed
+
+Mesh Node Hierarchy
+===================
+Service		org.bluez.mesh
+Interface	org.bluez.mesh.Node1
+Object path	/org/bluez/mesh/node<uuid>
+		where <uuid> is the Device UUID passed to Join(),
+		CreateNetwork() or Import()
+
+Methods:
+	void Send(object element_path, uint16 destination, uint16 key_index,
+						dict options, array{byte} data)
+
+		This method is used to send a message originated by a local
+		model.
+
+		The element_path parameter is the object path of an element from
+		a collection of the application elements (see Mesh Application
+		Hierarchy section).
+
+		The destination parameter contains the destination address. This
+		destination must be a uint16 to a unicast address, or a well
+		known group address.
+
+		The key_index parameter determines which application key to use
+		for encrypting the message. The key_index must be valid for that
+		element, i.e., the application key must be bound to a model on
+		this element. Otherwise, org.bluez.mesh.Error.NotAuthorized will
+		be returned.
+
+		The options parameter is a dictionary with the following keys
+		defined:
+
+			bool ForceSegmented
+				Specifies whether to force sending of a short
+				message as one-segment payload. If not present,
+				the default setting is "false".
+
+		The data parameter is an outgoing message to be encypted by the
+		bluetooth-meshd daemon and sent on.
+
+		Possible errors:
+			org.bluez.mesh.Error.NotAuthorized
+			org.bluez.mesh.Error.InvalidArguments
+			org.bluez.mesh.Error.NotFound
+
+	void DevKeySend(object element_path, uint16 destination, boolean remote,
+			uint16 net_index, dict options, array{byte} data)
+
+		This method is used to send a message originated by a local
+		model encoded with the device key of the remote node.
+
+		The element_path parameter is the object path of an element from
+		a collection of the application elements (see Mesh Application
+		Hierarchy section).
+
+		The destination parameter contains the destination address. This
+		destination must be a uint16 to a unicast address, or a well
+		known group address.
+
+		The remote parameter, if true, looks up the device key by the
+		destination address in the key database to encrypt the message.
+		If remote is true, but requested key does not exist, a NotFound
+		error will be returned. If set to false, the local node's
+		device key is used.
+
+		The net_index parameter is the subnet index of the network on
+		which the message is to be sent.
+
+		The options parameter is a dictionary with the following keys
+		defined:
+
+			bool ForceSegmented
+				Specifies whether to force sending of a short
+				message as one-segment payload. If not present,
+				the default setting is "false".
+
+		The data parameter is an outgoing message to be encypted by the
+		meshd daemon and sent on.
+
+		Possible errors:
+			org.bluez.mesh.Error.InvalidArguments
+			org.bluez.mesh.Error.NotFound
+
+	void AddNetKey(object element_path, uint16 destination,
+			uint16 subnet_index, uint16 net_index, boolean update)
+
+		This method is used to send add or update network key originated
+		by the local configuration client to a remote configuration
+		server.
+
+		The element_path parameter is the object path of an element from
+		a collection of the application elements (see Mesh Application
+		Hierarchy section).
+
+		The destination parameter contains the destination address. This
+		destination must be a uint16 to a nodes primary unicast address.
+
+		The subnet_index parameter refers to the subnet index of the
+		network that is being added or updated. This key must exist in
+		the local key database.
+
+		The net_index parameter is the subnet index of the network on
+		which the message is to be sent.
+
+		The update parameter indicates if this is an addition or an
+		update. If true, the subnet key must be in the phase 1 state of
+		the key update procedure.
+
+		Possible errors:
+			org.bluez.mesh.Error.InvalidArguments
+			org.bluez.mesh.Error.NotFound
+
+	void AddAppKey(object element_path, uint16 destination,
+			uint16 app_index, uint16 net_index, boolean update)
+
+		This method is used to send add or update network key originated
+		by the local configuration client to a remote configuration
+		server.
+
+		The element_path parameter is the object path of an element from
+		a collection of the application elements (see Mesh Application
+		Hierarchy section).
+
+		The destination parameter contains the destination address. This
+		destination must be a uint16 to a nodes primary unicast address.
+
+		The app_index parameter refers to the application key which is
+		being added or updated. This key must exist in the local key
+		database.
+
+		The net_index parameter is the subnet index of the network on
+		which the message is to be sent.
+
+		The update parameter indicates if this is an addition or an
+		update. If true, the subnet key must be in the phase 1 state of
+		the key update procedure.
+
+		Possible errors:
+			org.bluez.mesh.Error.InvalidArguments
+			org.bluez.mesh.Error.NotFound
+
+	void Publish(object element_path, uint16 model, dict options,
+							array{byte} data)
+
+		This method is used to send a publication originated by a local
+		model. If the model does not exist, or it has no publication
+		record, the method returns org.bluez.mesh.Error.DoesNotExist
+		error.
+
+		The element_path parameter is the object path of an element from
+		a collection of the application elements (see Mesh Application
+		Hierarchy section).
+
+		The model parameter contains a model ID, as defined by the
+		Bluetooth SIG. If the options dictionary contains a "Vendor"
+		key, then this ID is defined by the specified vendor.
+
+		The options parameter is a dictionary with the following keys
+		defined:
+
+			bool ForceSegmented
+				Specifies whether to force sending of a short
+				message as one-segment payload. If not present,
+				the default setting is "false".
+
+			uint16 Vendor
+				A 16-bit Company ID as defined by the
+				Bluetooth SIG. This key should only exist when
+				publishing on a Vendor defined model.
+
+		The data parameter is an outgoing message to be encypted by the
+		meshd daemon and sent on.
+
+		Since only one Publish record may exist per element-model, the
+		destination and key_index are obtained from the Publication
+		record cached by the daemon.
+
+		Possible errors:
+			org.bluez.mesh.Error.DoesNotExist
+			org.bluez.mesh.Error.InvalidArguments
+
+
+Properties:
+	dict Features [read-only]
+
+		The dictionary that contains information about feature support.
+		The following keys are defined:
+
+		boolean Friend
+
+			Indicates the ability to establish a friendship with a
+			Low Power node
+
+		boolean LowPower
+
+			Indicates support for operating in Low Power node mode
+
+		boolean Proxy
+
+			Indicates support for GATT proxy
+
+		boolean Relay
+			Indicates support for relaying messages
+
+	If a key is absent from the dictionary, the feature is not supported.
+	Otherwise, true means that the feature is enabled and false means that
+	the feature is disabled.
+
+	boolean Beacon [read-only]
+
+		This property indicates whether the periodic beaconing is
+		enabled (true) or disabled (false).
+
+	boolean IvUpdate [read-only]
+
+		When true, indicates that the network is in the middle of IV
+		Index Update procedure. This information is only useful for
+		provisioning.
+
+	uint32 IvIndex [read-only]
+
+		This property may be read at any time to determine the IV_Index
+		that the current network is on. This information is only useful
+		for provisioning.
+
+	uint32 SecondsSinceLastHeard [read-only]
+
+		This property may be read at any time to determine the number of
+		seconds since mesh network layer traffic was last detected on
+		this node's network.
+
+	array{uint16} Addresses [read-only]
+
+		This property contains unicast addresses of node's elements.
+
+	uint32 SequenceNumber [read-only]
+
+		This property may be read at any time to determine the
+		sequence number.
+
+Mesh Provisioning Hierarchy
+============================
+Service		org.bluez.mesh
+Interface	org.bluez.mesh.Management1
+Object path	/org/bluez/mesh/node<uuid>
+		where <uuid> is the Device UUID passed to Join(),
+		CreateNetwork() or Import()
+
+Methods:
+	void UnprovisionedScan(dict options)
+
+		This method is used by the application that supports
+		org.bluez.mesh.Provisioner1 interface to start listening
+		(scanning) for unprovisioned devices in the area.
+
+		The options parameter is a dictionary with the following keys
+		defined:
+
+		uint16 Seconds
+			Specifies number of seconds for scanning to be active.
+			If set to 0 or if this key is not present, then the
+			scanning will continue until UnprovisionedScanCancel()
+			or AddNode() methods are called. If not present, and a
+			remote server is specified, the default timeout will be
+			60 seconds.
+
+		uint16 Server
+			Specifies a remote server on which to perform scanning.
+			If not present, scanning will be local. If present,
+			the timeout must be between 1 and 60 seconds.
+
+		uint16 Subnet
+			Specifies a subnet for the remote server. If not
+			present, primary subnet will be used. If Server not
+			present, the Subnet will be ignored.
+
+		array{byte}[16] Filter
+			Specifies a specific UUID to search for. If not
+			present, all found UUIDs will be returned.
+
+		uint8 array Extended
+			Specifies variable number of Bluetooth AD types to
+			return with scan result. Only valid if a Filter has been
+			specified.
+
+		Each time a unique unprovisioned beacon is heard, the
+		ScanResult() method on the app will be called with the result.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.InvalidArguments
+			org.bluez.mesh.Error.NotAuthorized
+			org.bluez.mesh.Error.Busy
+
+	void UnprovisionedScanCancel(void)
+
+		This method is used by the application that supports
+		org.bluez.mesh.Provisioner1 interface to stop listening
+		(scanning) for unprovisioned devices in the area.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.InvalidArguments
+			org.bluez.mesh.Error.NotAuthorized
+
+	void AddNode(array{byte}[16] uuid, dict options)
+
+		This method is used by the application that supports
+		org.bluez.mesh.Provisioner1 interface to add the
+		unprovisioned device specified by uuid, to the Network.
+
+		The uuid parameter is a 16-byte array that contains Device UUID
+		of the unprovisioned device to be added to the network.
+
+		The options parameter is a dictionary that may contain
+		additional optional configuration info:
+
+		uint16 Server
+			Specifies a remote server to perform provisioning on. If
+			not present, provisioning will be done locally.
+
+		uint16 Subnet
+			Specifies a subnet for the remote server. If not
+			present, primary subnet will be used. If Server not
+			present Subnet will be ignored.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.InvalidArguments
+			org.bluez.mesh.Error.NotAuthorized
+
+	void Reprovision(uint16 unicast, dict options)
+
+		This method is used by the application that supports
+		org.bluez.mesh.Provisioner1 interface to perform one of the
+		Node Provisioning Protocol Interface procedures with a remote
+		node to refresh its device key, unicast address, and
+		composition. Remote node being reprovisioned must have the
+		Remote Provisioning Server model.
+
+		The unicast parameter is the 16-bit primary node address of
+		the remote node being reprovisioned.
+
+		The options parameter is a dictionary that may contain
+		additional optional configuration info:
+
+		uint8 NPPI
+			Specifies the Node Provisioning Protocol Interface
+			procedure, as defined in the Mesh Profile Specification:
+				0 - Device Key Refresh Only
+				1 - Node Address Refresh
+				2 - Node Composition Refresh
+
+			If not present, procedure 0 will be used.
+
+		uint16 Subnet
+			Specifies the subnet remote node is on. If not
+			present, primary subnet will be tried.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.InvalidArguments
+			org.bluez.mesh.Error.NotAuthorized
+
+	void CreateSubnet(uint16 net_index)
+
+		This method is used by the application to generate and add a new
+		network subnet key.
+
+		The net_index parameter is a 12-bit value (0x001-0xFFF)
+		specifying which net key to add.
+
+		This call affects the local bluetooth-meshd key database only.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.Failed
+			org.bluez.mesh.Error.InvalidArguments
+			org.bluez.mesh.Error.AlreadyExists
+
+	void ImportSubnet(uint16 net_index, array{byte}[16] net_key)
+
+		This method is used by the application to add a network subnet
+		key, that was originally generated by a remote Config Client.
+
+		The net_index parameter is a 12-bit value (0x000-0xFFF)
+		specifying which net key to add.
+
+		The net_key parameter is the 16-byte value of the net key being
+		imported.
+
+		This call affects the local bluetooth-meshd key database only.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.Failed
+			org.bluez.mesh.Error.InvalidArguments
+			org.bluez.mesh.Error.AlreadyExists
+
+	void UpdateSubnet(uint16 net_index)
+
+		This method is used by the application to generate a new network
+		subnet key, and set it's key refresh state to Phase 1.
+
+		The net_index parameter is a 12-bit value (0x000-0xFFF)
+		specifying which net key to update. Note that the subnet must
+		exist prior to updating.
+
+		This call affects the local bluetooth-meshd key database only.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.Failed
+			org.bluez.mesh.Error.InvalidArguments
+			org.bluez.mesh.Error.DoesNotExist
+			org.bluez.mesh.Error.Busy
+
+	void DeleteSubnet(uint16 net_index)
+
+		This method is used by the application that to delete a subnet.
+
+		The net_index parameter is a 12-bit value (0x001-0xFFF)
+		specifying which net key to delete. The primary net key (0x000)
+		may not be deleted.
+
+		This call affects the local bluetooth-meshd key database only.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.InvalidArguments
+
+	void SetKeyPhase(uint16 net_index, uint8 phase)
+		This method is used to set the flooding key update phase of the
+		given subnet. When finalizing the procedure, it is important
+		to CompleteAppKeyUpdate() on all app keys that have been
+		updated during the procedure prior to setting phase 3.
+
+		The net_index parameter is a 12-bit value (0x000-0xFFF)
+		specifying which subnet phase to set.
+
+		The phase parameter is used to cycle the local key database
+		through the phases as defined by the Mesh Profile Specification.
+		Allowed values:
+			0 - Cancel Key Refresh (May only be called from Phase 1,
+				and should never be called once the new key has
+				started propagating)
+			1 - Invalid Argument (see NetKeyUpdate method)
+			2 - Go to Phase 2 (May only be called from Phase 1)
+			3 - Complete Key Refresh procedure (May only be called
+				from Phase 2)
+
+		This call affects the local bluetooth-meshd key database only.
+		It is the responsibility of the application to maintain the key
+		refresh phases per the Mesh Profile Specification.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.Failed
+			org.bluez.mesh.Error.InvalidArguments
+			org.bluez.mesh.Error.DoesNotExist
+
+	void CreateAppKey(uint16 net_index, uint16 app_index)
+
+		This method is used by the application to generate and add a new
+		application key.
+
+		The net_index parameter is a 12-bit value (0x000-0xFFF)
+		specifying which net key to bind the application key to.
+
+		The app_index parameter is a 12-bit value (0x000-0xFFF)
+		specifying which app key to add.
+
+		This call affects the local bluetooth-meshd key database only.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.Failed
+			org.bluez.mesh.Error.InvalidArguments
+			org.bluez.mesh.Error.AlreadyExists
+			org.bluez.mesh.Error.DoesNotExist
+
+	void ImportAppKey(uint16 net_index, uint16 app_index,
+						array{byte}[16] app_key)
+
+		This method is used by the application to add an application
+		key, that was originally generated by a remote Config Client.
+
+		The net_index parameter is a 12-bit value (0x000-0xFFF)
+		specifying which net key to bind the application key to.
+
+		The app_index parameter is a 12-bit value (0x000-0xFFF)
+		specifying which app key to import.
+
+		The app_key parameter is the 16-byte value of the key being
+		imported.
+
+		This call affects the local bluetooth-meshd key database only.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.Failed
+			org.bluez.mesh.Error.InvalidArguments
+			org.bluez.mesh.Error.AlreadyExists
+			org.bluez.mesh.Error.DoesNotExist
+
+	void UpdateAppKey(uint16 app_index)
+
+		This method is used by the application to generate a new
+		application key.
+
+		The app_index parameter is a 12-bit value (0x000-0xFFF)
+		specifying which app key to update. Note that the subnet that
+		the key is bound to must exist and be in Phase 1.
+
+		This call affects the local bluetooth-meshd key database only.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.Failed
+			org.bluez.mesh.Error.InvalidArguments
+			org.bluez.mesh.Error.DoesNotExist
+			org.bluez.mesh.Error.InProgress
+
+	void DeleteAppKey(uint16 app_index)
+
+		This method is used by the application to delete an application
+		key.
+
+		The app_index parameter is a 12-bit value (0x000-0xFFF)
+		specifying which app key to delete.
+
+		This call affects the local bluetooth-meshd key database only.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.InvalidArguments
+
+	void ImportRemoteNode(uint16 primary, uint8 count,
+					array{byte}[16] device_key)
+
+		This method is used by the application to import a remote node
+		that has been provisioned by an external process.
+
+		The primary parameter specifies the unicast address of the
+		the node being imported.
+
+		The count parameter specifies the number of elements that are
+		assigned to this remote node.
+
+		The device_key parameter is the access layer key that will be
+		will used to decrypt privledged messages from this remote node.
+
+		This call affects the local bluetooth-meshd key database only.
+
+		It is an error to call this with address range overlapping
+		with local element addresses.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.Failed
+			org.bluez.mesh.Error.InvalidArguments
+
+	void DeleteRemoteNode(uint16 primary, uint8 count)
+
+		This method is used by the application to delete a remote node
+		from the local device key database.
+
+		The primary parameter specifies the unicast address of the
+		the node being deleted.
+
+		The count parameter specifies the number of elements that were
+		assigned to the remote node.
+
+		This call affects the local bluetooth-meshd key database only.
+
+		It is an error to call this with address range overlapping
+		with local element addresses.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.InvalidArguments
+
+	dict ExportKeys(void)
+
+		This method is used by the application to export information
+		about network keys, application keys and device keys present
+		in the local key database.
+
+		dict
+			A dictionary that contains information for the keys
+			stored in the keyring with the following keys defined:
+
+			NetKeys:
+				array{struct} net_keys:
+
+				uint16 index
+					Subnet index
+
+				array{byte}[16] key
+
+				dict:
+					A dictionary that contains optional
+					key info with the following keys
+					defined:
+
+					uint8 Phase
+						Key Refresh phase of the subnet
+
+					array{byte}[16] OldKey
+
+					array{struct} AppKeys:
+
+						uint16 index
+
+							Application key index
+
+						array{byte}[16] key
+
+						dict:
+							A dictionary of optional
+							key info with the
+							following keys defined:
+
+							array{byte}[16] OldKey
+
+			DevKeys:
+				array{struct} dev_keys:
+
+				Device Key information for known remote
+				nodes in the configured Mesh network
+
+				uint16 unicast
+
+					Unicast address of the node's primary
+					element
+
+				array{byte}[16] key
+
+Mesh Application Hierarchy
+==========================
+Service		unique name
+Interface	org.bluez.mesh.Application1
+Object path	<app_root>
+
+An application is a collection of elements that host SIG defined and vendor
+specific models. It is expected that an application implements
+org.freedesktop.DBus.ObjectManager interface at app_root path.
+
+An example mesh application hierarchy may look like this:
+
+-> /com/example
+  |   - org.freedesktop.DBus.ObjectManager
+  |
+  -> /com/example/application
+  |   - org.bluez.mesh.Application1
+  |   - org.bluez.mesh.Attention1 (optional)
+  |   - org.bluez.mesh.Provisioner1 (optional,Provisioner)
+  |
+  -> /com/example/agent
+  |   - org.bluez.mesh.ProvisionAgent1
+  |
+  -> /com/example/ele00
+  |   - org.bluez.mesh.Element1
+  |
+  -> /com/example/ele01
+  |   - org.bluez.mesh.Element1
+  |
+  ...
+  -> /com/example/elexx
+      - org.bluez.mesh.Element1
+
+Methods:
+	void JoinComplete(uint64 token)
+
+		This method is called when the node provisioning initiated
+		by a Join() method call successfully completed.
+
+		The token parameter serves as a unique identifier of the
+		particular node. The token must be preserved by the application
+		in order to authenticate itself to the mesh daemon and attach to
+		the network as a mesh node by calling Attach() method or
+		permanently remove the identity of the mesh node by calling
+		Leave() method.
+
+		If this method returns an error, the daemon will assume that the
+		application failed to preserve the token, and will remove the
+		freshly created node.
+
+	void JoinFailed(string reason)
+
+		This method is called when the node provisioning initiated by
+		Join() has failed.
+
+		The reason parameter identifies the reason for provisioning
+		failure. The defined values are: "timeout", "bad-pdu",
+		"confirmation-failed", "out-of-resources", "decryption-error",
+		"unexpected-error", "cannot-assign-addresses".
+
+Properties:
+	uint16 CompanyID [read-only]
+
+		A 16-bit Bluetooth-assigned Company Identifier of the vendor as
+		defined by Bluetooth SIG
+
+	uint16 ProductID [read-only]
+
+		A 16-bit vendor-assigned product identifier
+
+	uint16 VersionID [read-only]
+
+		A 16-bit vendor-assigned product version identifier
+
+	uint16 CRPL [read-only, optional]
+
+		A 16-bit minimum number of replay protection list entries
+
+
+Mesh Element Hierarchy
+======================
+Service		unique name
+Interface	org.bluez.mesh.Element1
+Object path	<app_defined_element_path>
+
+Methods:
+	void MessageReceived(uint16 source, uint16 key_index,
+					variant destination, array{byte} data)
+
+		This method is called by bluetooth-meshd daemon when a message
+		arrives addressed to the application.
+
+		The source parameter is unicast address of the remote
+		node-element that sent the message.
+
+		The key_index parameter indicates which application key has been
+		used to decode the incoming message. The same key_index should
+		be used by the application when sending a response to this
+		message (in case a response is expected).
+
+		The destination parameter contains the destination address of
+		received message. Underlying variant types are:
+
+		uint16
+
+			Destination is an unicast address, or a well known
+			group address
+
+		array{byte}
+
+			Destination is a virtual address label
+
+		The data parameter is the incoming message.
+
+	void DevKeyMessageReceived(uint16 source, boolean remote,
+					uint16 net_index, array{byte} data)
+
+		This method is called by meshd daemon when a message arrives
+		addressed to the application, which was sent with the remote
+		node's device key.
+
+		The source parameter is unicast address of the remote
+		node-element that sent the message.
+
+		The remote parameter if true indicates that the device key
+		used to decrypt the message was from the sender. False
+		indicates that the local nodes device key was used, and the
+		message has permissions to modify local states.
+
+		The net_index parameter indicates what subnet the message was
+		received on, and if a response is required, the same subnet
+		must be used to send the response.
+
+		The data parameter is the incoming message.
+
+	void UpdateModelConfiguration(uint16 model_id, dict config)
+
+		This method is called by bluetooth-meshd daemon when a model's
+		configuration is updated.
+
+		The model_id parameter contains BT SIG Model Identifier or, if
+		Vendor key is present in config dictionary, a 16-bit
+		vendor-assigned Model Identifier.
+
+		The config parameter is a dictionary with the following keys
+		defined:
+
+		array{uint16} Bindings
+
+			Indices of application keys bound to the model
+
+		uint32 PublicationPeriod
+
+			Model publication period in milliseconds
+
+		uint16 Vendor
+
+			A 16-bit Bluetooth-assigned Company Identifier of the
+			vendor as defined by Bluetooth SIG
+
+		array{variant} Subscriptions
+
+			Addresses the model is subscribed to.
+
+			Each address is provided either as uint16 for group
+			addresses, or as array{byte} for virtual labels.
+
+Properties:
+	uint8 Index [read-only]
+
+		Element index. It is required that the application follows
+		sequential numbering scheme for the elements, starting with 0.
+
+	array{(uint16 id, dict caps)} Models [read-only]
+
+		An array of SIG Models:
+
+			id - SIG Model Identifier
+
+			options - a dictionary that may contain additional model
+			info. The following keys are defined:
+
+				boolean Publish - indicates whether the model
+					supports publication mechanism. If not
+					present, publication is enabled.
+
+				boolean Subscribe - indicates whether the model
+					supports subscription mechanism. If not
+					present, subscriptons are enabled.
+
+		The array may be empty.
+
+
+	array{(uint16 vendor, uint16 id, dict options)} VendorModels [read-only]
+
+		An array of Vendor Models:
+
+			vendor - a 16-bit Bluetooth-assigned Company ID as
+			defined by Bluetooth SIG.
+
+			id - a 16-bit vendor-assigned Model Identifier
+
+			options - a dictionary that may contain additional model
+			info. The following keys are defined:
+
+				boolean Publish - indicates whether the model
+					supports publication mechanism
+
+				boolean Subscribe - indicates whether the model
+					supports subscription mechanism
+
+		The array may be empty.
+
+	uint16 Location [read-only, optional]
+
+		Location descriptor as defined in the GATT Bluetooth Namespace
+		Descriptors section of the Bluetooth SIG Assigned Numbers
+
+
+Mesh Attention Hierarchy
+========================
+Service		unique name
+Interface	org.bluez.mesh.Attention1
+Object path	freely definable
+
+This is an optional interface that implements health attention timer.
+
+Methods:
+	void SetTimer(uint8 element_index, uint16 time)
+
+		The element_index parameter is the element's index within the
+		node where the health server model is hosted.
+
+		The time parameter indicates how many seconds the attention
+		state shall be on.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.NotSupported
+
+	uint16 GetTimer(uint16 element)
+
+		The element parameter is the unicast address within the node
+		where the health server model is hosted.
+
+		Returns the number of seconds for how long the attention action
+		remains staying on.
+
+		PossibleErrors:
+			org.bluez.mesh.Error.NotSupported
+
+
+Mesh Provisioner Hierarchy
+============================
+Service		unique name
+Interface	org.bluez.mesh.Provisioner1
+Object path	freely definable
+
+	void ScanResult(int16 rssi, array{byte} data, dict options)
+
+		The method is called from the bluetooth-meshd daemon when a
+		unique UUID has been seen during UnprovisionedScan() for
+		unprovsioned devices.
+
+		The rssi parameter is a signed, normalized measurement of the
+		signal strength of the recieved unprovisioned beacon.
+
+		The data parameter is a variable length byte array, that may
+		have 1, 2 or 3 distinct fields contained in it including the 16
+		byte remote device UUID (always), a 16 bit mask of OOB
+		authentication flags (optional), and a 32 bit URI hash (if URI
+		bit set in OOB mask). Whether these fields exist or not is a
+		decision of the unprovisioned device.
+
+		The options parameter is a dictionary that may contain
+		additional optional configuration info:
+
+		uint16 Server
+			Specifies the remote server that received the
+			Unprovisioned beacon. If not present, beacon was
+			received locally.
+
+		uint8 array ExtendedData
+			If Extended data was requested during scanning, any
+			received data will be returned here.
+
+		If a beacon with a UUID that has already been reported is
+		recieved by the daemon, it will be silently discarded unless it
+		was recieved at a higher rssi power level.
+
+
+	uint16 net_index, uint16 unicast RequestProvData(uint8 count)
+
+		This method is implemented by a Provisioner capable application
+		and is called when the remote device has been fully
+		authenticated and confirmed.
+
+		The count parameter is the number of consecutive unicast
+		addresses the remote device is requesting.
+
+		Return Parameters are from the Mesh Profile Spec:
+		net_index - Subnet index of the net_key
+		unicast - Primary Unicast address of the new node
+
+		PossibleErrors:
+			org.bluez.mesh.Error.Abort
+
+	uint16 unicast RequestReprovData(uint16 original, uint8 count)
+
+		This method is implemented by a Provisioner capable application
+		and is called when the remote node being reprovisioned has been
+		fully authenticated and confirmed. This method will only be
+		called if the NPPI-1 procedure (Node Address Refresh) is being
+		performed.
+
+		The original parameter is the current unicast address of the
+		node being reprovisioned.
+
+		The count parameter is the number of consecutive unicast
+		addresses the remote node is requesting.
+
+		Return Parameter:
+		unicast - Primary Unicast address of the new node
+
+		PossibleErrors:
+			org.bluez.mesh.Error.Abort
+
+	void AddNodeComplete(array{byte}[16] uuid, uint16 unicast, uint8 count)
+
+		This method is called when the node provisioning initiated
+		by an AddNode() method call successfully completed.
+
+		The unicast parameter is the primary address that has been
+		assigned to the new node, and the address of it's config server.
+
+		The count parameter is the number of unicast addresses assigned
+		to the new node.
+
+		The new node may now be sent messages using the credentials
+		supplied by the RequestProvData method.
+
+	void ReprovComplete(uint16 original, uint8 nppi, uint16 unicast,
+								uint8 count)
+
+		This method is called when the node Reprovisioning initiated
+		by a Reprovision() method call successfully completed.
+
+		The original parameter is the former primary address of the
+		node that has been reprovisioned.
+
+		The nppi parameter indicates which NPPI procedure was performed.
+		If procedure 1 or 2 was performed, the node is materially
+		different than it was before reprovisioning, and Composition,
+		Bindings, Publication and Subscription settings should be
+		refreshed.
+
+		The unicast parameter is the new primary address that has been
+		assigned to the node, If NPPI procedure 1 was performed this
+		value may be different from the original. If procedure 0 or 2
+		was performed, the original and new primary address should be
+		the same.
+
+		The count parameter is the number of unicast addresses assigned
+		to the node.
+
+		The node may now be sent messages using the credentials
+		supplied by the RequestReprovData method.
+
+	void AddNodeFailed(array{byte}[16] uuid, string reason)
+
+		This method is called when the node provisioning initiated by
+		AddNode() has failed. Depending on how far Provisioning
+		proceeded before failing, some cleanup of cached data may be
+		required.
+
+		The reason parameter identifies the reason for provisioning
+		failure. The defined values are: "aborted", "timeout",
+		"bad-pdu", "confirmation-failed", "out-of-resources",
+		"decryption-error", "unexpected-error",
+		"cannot-assign-addresses".
+
+	void ReprovFailed(uint16 unicast, string reason)
+
+		This method is called when node reprovisioning initiated by
+		Reprovision() has failed. If reprovisioning has failed, the
+		prior credentials of the remote node may still be valid.
+
+		The reason parameter identifies the reason for provisioning
+		failure. The defined values are: "aborted", "timeout",
+		"bad-pdu", "confirmation-failed", "out-of-resources",
+		"decryption-error", "unexpected-error",
+		"cannot-assign-addresses".
+
+Provisioning Agent Hierarchy
+============================
+Service		unique name
+Interface	org.bluez.mesh.ProvisionAgent1
+Object path	freely definable
+
+Methods:
+	array{byte} PrivateKey()
+
+		This method is called during provisioning if the Provisioner
+		has requested Out-Of-Band ECC key exchange. The Private key is
+		returned to the Daemon, and the Public Key is delivered to the
+		remote Provisioner using a method that does not involve the
+		Bluetooth Mesh system. The Private Key returned must be 32
+		octets in size, or the Provisioning procedure will fail and be
+		canceled.
+
+		This function will only be called if the Provisioner has
+		requested pre-determined keys to be exchanged Out-of-Band, and
+		the local role is Unprovisioned device.
+
+	array{byte} PublicKey()
+
+		This method is called during provisioning if the local device is
+		the Provisioner, and is requestng Out-Of-Band ECC key exchange.
+		The Public key is returned to the Daemon that is the matched
+		pair of the Private key of the remote device. The Public Key
+		returned must be 64 octets in size, or the Provisioning
+		procedure will fail and be canceled.
+
+		This function will only be called if the Provisioner has
+		requested pre-determined keys to be exchanged Out-of-Band, and
+		the local role is Provisioner.
+
+	void DisplayString(string value)
+
+		This method is called when the Daemon has something important
+		for the Agent to Display, but does not require any additional
+		input locally. For instance: "Enter "ABCDE" on remote device".
+
+	void DisplayNumeric(string type, uint32 number)
+
+		This method is called when the Daemon has something important
+		for the Agent to Display, but does not require any additional
+		input locally. For instance: "Enter 14939264 on remote device".
+
+		The type parameter indicates the display method. Allowed values
+		are:
+			"blink" - Locally blink LED
+			"beep" - Locally make a noise
+			"vibrate" - Locally vibrate
+			"out-numeric" - Display value to enter remotely
+			"push" - Request pushes on remote button
+			"twist" - Request twists on remote knob
+
+		The number parameter is the specific value represented by the
+		Prompt.
+
+	uint32 PromptNumeric(string type)
+
+		This method is called when the Daemon requests the user to
+		enter a decimal value between 1-99999999.
+
+		The type parameter indicates the input method. Allowed values
+		are:
+			"blink" - Enter times remote LED blinked
+			"beep" - Enter times remote device beeped
+			"vibrate" - Enter times remote device vibrated
+			"in-numeric" - Enter remotely displayed value
+			"push" - Push local button remotely requested times
+			"twist" - Twist local knob remotely requested times
+
+
+		This agent should prompt the user for specific input. For
+		instance: "Enter value being displayed by remote device".
+
+	array{byte}[16] PromptStatic(string type)
+
+		This method is called when the Daemon requires a 16 octet byte
+		array, as an Out-of-Band authentication.
+
+		The type parameter indicates the input method. Allowed values
+		are:
+			"static-oob" - return 16 octet array
+			"in-alpha" - return 16 octet alpha array
+
+		The Static data returned must be 16 octets in size, or the
+		Provisioning procedure will fail and be canceled. If input type
+		is "in-alpha", the printable characters should be
+		left-justified, with trailing 0x00 octets filling the remaining
+		bytes.
+
+	void Cancel()
+
+		This method gets called by the daemon to cancel any existing
+		Agent Requests. When called, any pending user input should be
+		canceled, and any display requests removed.
+
+
+Properties:
+	array{string} Capabilities [read-only]
+
+		An array of strings with the following allowed values:
+			"blink"
+			"beep"
+			"vibrate"
+			"out-numeric"
+			"out-alpha"
+			"push"
+			"twist"
+			"in-numeric"
+			"in-alpha"
+			"static-oob"
+			"public-oob"
+
+	array{string} OutOfBandInfo [read-only, optional]
+
+		Indicates availability of OOB data. An array of strings with the
+		following allowed values:
+			"other"
+			"uri"
+			"machine-code-2d"
+			"bar-code"
+			"nfc"
+			"number"
+			"string"
+			"on-box"
+			"in-box"
+			"on-paper",
+			"in-manual"
+			"on-device"
+
+	string URI [read-only, optional]
+
+		Uniform Resource Identifier points to out-of-band (OOB)
+		information (e.g., a public key)
--- /dev/null
+++ ppa/doc/security-bugs.txt
@@ -0,0 +1,88 @@
+Security bugs
+=============
+
+BlueZ developers take security very seriously.  As such, we'd like to know
+when a security bug is found so that it can be fixed and disclosed as quickly
+as possible.  Please report security bugs to the BlueZ security team.
+
+
+Contact
+-------
+
+The BlueZ security team can be contacted by email at <security@bluez.org>.
+This is a private list of security officers who will help verify the bug
+report and develop and release a fix.  If you already have a fix, please
+include it with your report, as that can speed up the process considerably.
+
+As it is with any bug, the more information provided the easier it will
+be to diagnose and fix.  Any exploit code is very helpful and will not
+be released without consent from the reporter unless it has already been
+made public.
+
+Please send plain text emails without attachments where possible.
+
+
+Disclosure and embargoed information
+------------------------------------
+
+The security list is not a disclosure channel.  For that, see Coordination
+below.
+
+Once a robust fix has been developed, the release process starts.  Fixes
+for publicly known bugs are released immediately.
+
+Although our preference is to release fixes for publicly undisclosed bugs
+as soon as they become available, this may be postponed at the request of
+the reporter or an affected party for up to 7 calendar days from the start
+of the release process, with an exceptional extension to 14 calendar days
+if it is agreed that the criticality of the bug requires more time.  The
+only valid reason for deferring the publication of a fix is to accommodate
+the logistics of QA and large scale rollouts which require release
+coordination.
+
+While embargoed information may be shared with trusted individuals in
+order to develop a fix, such information will not be published alongside
+the fix or on any other disclosure channel without the permission of the
+reporter.  This includes but is not limited to the original bug report
+and followup discussions (if any), exploits, CVE information or the
+identity of the reporter.
+
+In other words our only interest is in getting bugs fixed.  All other
+information submitted to the security list and any followup discussions
+of the report are treated confidentially even after the embargo has been
+lifted, in perpetuity.
+
+
+Coordination
+------------
+
+Fixes for sensitive bugs, such as those that might lead to privilege
+escalations, may need to be coordinated with the private
+<linux-distros@vs.openwall.org> mailing list so that distribution vendors
+are well prepared to issue a fixed package upon public disclosure of the
+upstream fix.  Distros will need some time to test the proposed patch and
+will generally request at least a few days of embargo, and vendor update
+publication prefers to happen Tuesday through Thursday. When appropriate,
+the security team can assist with this coordination, or the reporter can
+include linux-distros from the start.  In this case, remember to prefix
+the email Subject line with "[vs]" as described in the linux-distros wiki:
+<http://oss-security.openwall.org/wiki/mailing-lists/distros#how-to-use-the-lists>
+
+
+CVE assignment
+--------------
+
+The security team does not normally assign CVEs, nor do we require them
+for reports or fixes, as this can needlessly complicate the process and
+may delay the bug handling. If a reporter wishes to have a CVE identifier
+assigned ahead of public disclosure, they will need to contact the private
+linux-distros list, described above. When such a CVE identifier is known
+before a patch is provided, it is desirable to mention it in the commit
+message if the reporter agrees.
+
+
+Non-disclosure agreements
+-------------------------
+
+The BlueZ security team is not a formal body and therefore unable to enter
+any non-disclosure agreements.
--- /dev/null
+++ ppa/doc/tester.config
@@ -0,0 +1,59 @@
+CONFIG_PCI=y
+CONFIG_VIRTIO=y
+CONFIG_VIRTIO_PCI=y
+
+CONFIG_NET=y
+CONFIG_INET=y
+
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+
+CONFIG_9P_FS=y
+CONFIG_9P_FS_POSIX_ACL=y
+
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+
+CONFIG_DEVTMPFS=y
+CONFIG_DEBUG_FS=y
+
+CONFIG_BT=y
+CONFIG_BT_BREDR=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_LE=y
+CONFIG_BT_HS=y
+CONFIG_BT_MSFTEXT=y
+CONFIG_BT_AOSPEXT=y
+CONFIG_BT_FEATURE_DEBUG=y
+
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIVHCI=y
+
+CONFIG_CRYPTO_CMAC=y
+CONFIG_CRYPTO_USER_API=y
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
+
+CONFIG_UNIX=y
+
+CONFIG_UHID=y
+
+CONFIG_DEBUG_KERNEL=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_LOCK_ALLOC=y
+CONFIG_DEBUG_ATOMIC_SLEEP=y
+CONFIG_PROVE_LOCKING=y
+CONFIG_PROVE_RCU=y
+CONFIG_LOCKDEP=y
+CONFIG_DEBUG_MUTEXES=y
+CONFIG_KASAN=y
--- /dev/null
+++ ppa/doc/thermometer-api.txt
@@ -0,0 +1,134 @@
+BlueZ D-Bus Thermometer API description
+***************************************
+
+	Santiago Carot-Nemesio <sancane@gmail.com>
+
+Health Thermometer Manager hierarchy
+====================================
+
+Service		org.bluez
+Interface	org.bluez.ThermometerManager1
+Object path	[variable prefix]/{hci0,hci1,...}
+
+Methods		RegisterWatcher(object agent)
+
+			Registers a watcher to monitor scanned measurements.
+			This agent will be notified about final temperature
+			measurements.
+
+			Possible Errors: org.bluez.Error.InvalidArguments
+
+		UnregisterWatcher(object agent)
+
+			Unregisters a watcher.
+
+		EnableIntermediateMeasurement(object agent)
+
+			Enables intermediate measurement notifications
+			for this agent. Intermediate measurements will
+			be enabled only for thermometers which support it.
+
+			Possible Errors: org.bluez.Error.InvalidArguments
+
+		DisableIntermediateMeasurement(object agent)
+
+			Disables intermediate measurement notifications
+			for this agent. It will disable notifications in
+			thermometers when the last agent removes the
+			watcher for intermediate measurements.
+
+			Possible Errors: org.bluez.Error.InvalidArguments
+					org.bluez.Error.NotFound
+
+Health Thermometer Profile hierarchy
+====================================
+
+Service		org.bluez
+Interface	org.bluez.Thermometer1
+Object path	[variable prefix]/{hci0,hci1,...}/dev_XX_XX_XX_XX_XX_XX
+
+
+Properties	boolean Intermediate [readonly]
+
+			True if the thermometer supports intermediate
+			measurement notifications.
+
+		uint16 Interval (optional) [readwrite]
+
+			The Measurement Interval defines the time (in
+			seconds) between measurements. This interval is
+			not related to the intermediate measurements and
+			must be defined into a valid range. Setting it
+			to zero means that no periodic measurements will
+			be taken.
+
+		uint16 Maximum (optional) [readonly]
+
+			Defines the maximum value allowed for the interval
+			between periodic measurements.
+
+		uint16 Minimum (optional) [readonly]
+
+			Defines the minimum value allowed for the interval
+			between periodic measurements.
+
+
+Health Thermometer Watcher hierarchy
+====================================
+
+Service		unique name
+Interface	org.bluez.ThermometerWatcher1
+Object path	freely definable
+
+Methods		void MeasurementReceived(dict measurement)
+
+			This callback gets called when a measurement has been
+			scanned in the thermometer.
+
+			Measurement:
+
+				int16 Exponent:
+				int32 Mantissa:
+
+					Exponent and Mantissa values as
+					extracted from float value defined by
+					IEEE-11073-20601.
+
+					Measurement value is calculated as
+					(Mantissa) * (10^Exponent)
+
+					For special cases Exponent is
+					set to 0 and Mantissa is set to
+					one of following values:
+
+					+(2^23 - 1)	NaN (invalid or
+							missing data)
+					-(2^23)		NRes
+					+(2^23 - 2)	+Infinity
+					-(2^23 - 2)	-Infinity
+
+				string Unit:
+
+					Possible values: "celsius" or
+							"fahrenheit"
+
+				uint64 Time (optional):
+
+					Time of measurement, if
+					supported by device.
+					Expressed in seconds since epoch.
+
+				string Type (optional):
+
+					Only present if measurement type
+					is known.
+
+					Possible values: "armpit", "body",
+						"ear", "finger", "intestines",
+						"mouth", "rectum", "toe",
+						"tympanum"
+
+				string Measurement:
+
+					Possible values: "final" or
+							"intermediate"
--- /dev/null
+++ ppa/mesh/README
@@ -0,0 +1,95 @@
+Bluetooth Mesh Daemon
+*********************
+
+Copyright (C) 2019  Intel Corporation. All rights reserved.
+
+Compilation and installation
+============================
+
+In addition to main BlueZ requirements, MeshCtl needs the following:
+	- json-c library
+
+Configuration and options
+=========================
+
+	--enable-mesh
+
+		Build mesh daemon and other Bluetooth Mesh based tools
+
+Current implementation of the mesh daemon requires exclusive access to
+a Bluetooth controller.
+The AutoEnable option in the installed main.conf should be set to "false".
+
+Storage
+=======
+
+Default storage directory is /var/lib/bluetooth/mesh.
+
+The directory contains the provisioned nodes configurations.
+Each node has its own subdirectory, named after node's Device UUID (32-digit
+hexadecimal string) that is generated by the application that created a node.
+
+Each subdirectory contains the following files:
+	- node.json:
+		node configuration and is populated by the
+		daemon based on the configuration commands from a
+		provisioner/configuration client
+	- node.json.bak:
+		a backup that the last known good node configuration.
+	- seq_num:
+		File containing next sequence number to use
+	- seq_num.bak:
+		Backup of the sequence number. This may be larger than the
+		actual sequence number being used at runtime, to prevent re-use
+		of sequence numbers in the event of an unexpected restart.
+	- ./rpl/:
+		Directory to store the sequence numbers of remote nodes, as
+		required by Replay Protection List (RPL) parameters.
+		- xxxx:
+			Files named for remote Unicast addresses, and contain
+			last received iv_index + seq_num from each SRC address.
+	- ./dev_keys/:
+		Directory to store remote Device keys. This is only created/used
+		by Configuration Client (Network administration) nodes.
+		- xxxx:
+			Files named for remote Unicast addresses, and contains
+			16 octet key.
+	- ./net_keys/:
+		Directory to store network subnet keys. This is only
+		created/used by Configuration Client (Network administration)
+		nodes.
+		- xxx:
+			Files named for subnet index, and contains key refresh
+			phase, and old/new versions of the key.
+	- ./app_keys/:
+		Directory to store application keys. This is only created/used
+		by Configuration Client (Network administration) nodes.
+		- xxx:
+			Files named for application index, and contains bound
+			subnet index, and old/new versions of the key.
+
+The node.json and node.json.bak are in JSON format. All other files are stored
+in little endian binary format.
+
+Known Issues
+============
+
+Bluetooth Mesh makes heavy usage of AEAD-AES_CCM encryption, which is
+implemented in the Linux kernel on most platforms. Some platforms, including
+those with kernel versions including and prior to v4.8, did *not* correctly
+implement the AEAD encryption routines. If Mesh is to be ported to such a
+system, it will be the responsibility of the vendor to provide support for
+AEAD-AES_CCM encryption by some other method.
+
+Support for the required AEAD routines can be determined by running the unit
+tests provided with the ELL libraries used by Mesh. Specifically, the tests
+found in .../ell/unit/test-cipher.c
+
+Information
+===========
+
+Mailing lists:
+	linux-bluetooth@vger.kernel.org
+
+For additional information about the project visit BlueZ web site:
+	http://www.bluez.org
--- /dev/null
+++ ppa/obexd/plugins/messages-tracker.c
@@ -0,0 +1,332 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ *
+ *  OBEX Server
+ *
+ *  Copyright (C) 2010-2011  Nokia Corporation
+ *
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <errno.h>
+#include <glib.h>
+#include <string.h>
+
+#include "messages.h"
+
+struct message_folder {
+	char *name;
+	GSList *subfolders;
+	char *query;
+};
+
+struct session {
+	char *cwd;
+	struct message_folder *folder;
+	char *name;
+	uint16_t max;
+	uint16_t offset;
+	void *user_data;
+	void (*folder_list_cb)(void *session, int err, uint16_t size,
+					const char *name, void *user_data);
+};
+
+static struct message_folder *folder_tree = NULL;
+
+static struct message_folder *get_folder(const char *folder)
+{
+	GSList *folders = folder_tree->subfolders;
+	struct message_folder *last = NULL;
+	char **path;
+	int i;
+
+	if (g_strcmp0(folder, "/") == 0)
+		return folder_tree;
+
+	path = g_strsplit(folder, "/", 0);
+
+	for (i = 1; path[i] != NULL; i++) {
+		gboolean match_found = FALSE;
+		GSList *l;
+
+		for (l = folders; l != NULL; l = g_slist_next(l)) {
+			struct message_folder *folder = l->data;
+
+			if (g_strcmp0(folder->name, path[i]) == 0) {
+				match_found = TRUE;
+				last = l->data;
+				folders = folder->subfolders;
+				break;
+			}
+		}
+
+		if (!match_found) {
+			g_strfreev(path);
+			return NULL;
+		}
+	}
+
+	g_strfreev(path);
+
+	return last;
+}
+
+static struct message_folder *create_folder(const char *name, const char *query)
+{
+	struct message_folder *folder = g_new0(struct message_folder, 1);
+
+	folder->name = g_strdup(name);
+	folder->query = g_strdup(query);
+
+	return folder;
+}
+
+static void destroy_folder_tree(void *root)
+{
+	struct message_folder *folder = root;
+	GSList *tmp, *next;
+
+	if (folder == NULL)
+		return;
+
+	g_free(folder->name);
+	g_free(folder->query);
+
+	tmp = folder->subfolders;
+	while (tmp != NULL) {
+		next = g_slist_next(tmp);
+		destroy_folder_tree(tmp->data);
+		tmp = next;
+	}
+
+	g_slist_free(folder->subfolders);
+	g_free(folder);
+}
+
+static void create_folder_tree(void)
+{
+	struct message_folder *parent, *child;
+
+	folder_tree = create_folder("/", "FILTER (!BOUND(?msg))");
+
+	parent = create_folder("telecom", "FILTER (!BOUND(?msg))");
+	folder_tree->subfolders = g_slist_append(folder_tree->subfolders,
+								parent);
+
+	child = create_folder("msg", "FILTER (!BOUND(?msg))");
+	parent->subfolders = g_slist_append(parent->subfolders, child);
+
+	parent = child;
+
+	child = create_folder("inbox", "?msg nmo:isSent \"false\" ; "
+				"nmo:isDeleted \"false\" ; "
+				"nmo:isDraft \"false\". ");
+	parent->subfolders = g_slist_append(parent->subfolders, child);
+
+	child = create_folder("sent", "?msg nmo:isDeleted \"false\" ; "
+				"nmo:isSent \"true\" . ");
+	parent->subfolders = g_slist_append(parent->subfolders, child);
+
+	child = create_folder("deleted", "?msg nmo:isDeleted \"true\" . ");
+	parent->subfolders = g_slist_append(parent->subfolders, child);
+}
+
+int messages_init(void)
+{
+	create_folder_tree();
+
+	return 0;
+}
+
+void messages_exit(void)
+{
+	destroy_folder_tree(folder_tree);
+}
+
+int messages_connect(void **s)
+{
+	struct session *session = g_new0(struct session, 1);
+
+	session->cwd = g_strdup("/");
+	session->folder = folder_tree;
+
+	*s = session;
+
+	return 0;
+}
+
+void messages_disconnect(void *s)
+{
+	struct session *session = s;
+
+	g_free(session->cwd);
+	g_free(session);
+}
+
+int messages_set_notification_registration(void *session,
+		void (*send_event)(void *session,
+			const struct messages_event *event, void *user_data),
+		void *user_data)
+{
+	return -ENOSYS;
+}
+
+int messages_set_folder(void *s, const char *name, gboolean cdup)
+{
+	struct session *session = s;
+	char *newrel = NULL;
+	char *newabs;
+	char *tmp;
+
+	if (name && (strchr(name, '/') || strcmp(name, "..") == 0))
+		return -EBADR;
+
+	if (cdup) {
+		if (session->cwd[0] == 0)
+			return -ENOENT;
+
+		newrel = g_path_get_dirname(session->cwd);
+
+		/* We use empty string for indication of the root directory */
+		if (newrel[0] == '.' && newrel[1] == 0)
+			newrel[0] = 0;
+	}
+
+	tmp = newrel;
+	if (!cdup && (!name || name[0] == 0))
+		newrel = g_strdup("");
+	else
+		newrel = g_build_filename(newrel ? newrel : session->cwd, name,
+									NULL);
+	g_free(tmp);
+
+	if (newrel[0] != '/')
+		newabs = g_build_filename("/", newrel, NULL);
+	else
+		newabs = g_strdup(newrel);
+
+	session->folder = get_folder(newabs);
+	if (session->folder == NULL) {
+		g_free(newrel);
+		g_free(newabs);
+
+		return -ENOENT;
+	}
+
+	g_free(newrel);
+	g_free(session->cwd);
+	session->cwd = newabs;
+
+	return 0;
+}
+
+static gboolean async_get_folder_listing(void *s)
+{
+	struct session *session = s;
+	gboolean count = FALSE;
+	int folder_count = 0;
+	char *path = NULL;
+	struct message_folder *folder;
+	GSList *dir;
+
+	if (session->name && strchr(session->name, '/') != NULL)
+		goto done;
+
+	path = g_build_filename(session->cwd, session->name, NULL);
+
+	if (path == NULL || strlen(path) == 0)
+		goto done;
+
+	folder = get_folder(path);
+
+	if (folder == NULL)
+		goto done;
+
+	if (session->max == 0) {
+		session->max = 0xffff;
+		session->offset = 0;
+		count = TRUE;
+	}
+
+	for (dir = folder->subfolders; dir &&
+				(folder_count - session->offset) < session->max;
+				folder_count++, dir = g_slist_next(dir)) {
+		struct message_folder *dir_data = dir->data;
+
+		if (count == FALSE && session->offset <= folder_count)
+			session->folder_list_cb(session, -EAGAIN, 0,
+					dir_data->name, session->user_data);
+	}
+
+ done:
+	session->folder_list_cb(session, 0, folder_count, NULL,
+							session->user_data);
+
+	g_free(path);
+	g_free(session->name);
+
+	return FALSE;
+}
+
+int messages_get_folder_listing(void *s, const char *name,
+					uint16_t max, uint16_t offset,
+					messages_folder_listing_cb callback,
+					void *user_data)
+{
+	struct session *session = s;
+	session->name = g_strdup(name);
+	session->max = max;
+	session->offset = offset;
+	session->folder_list_cb = callback;
+	session->user_data = user_data;
+
+	g_idle_add_full(G_PRIORITY_DEFAULT_IDLE, async_get_folder_listing,
+						session, NULL);
+
+	return 0;
+}
+
+int messages_get_messages_listing(void *session, const char *name,
+				uint16_t max, uint16_t offset,
+				uint8_t subject_len,
+				const struct messages_filter *filter,
+				messages_get_messages_listing_cb callback,
+				void *user_data)
+{
+	return -ENOSYS;
+}
+
+int messages_get_message(void *session, const char *handle,
+				unsigned long flags,
+				messages_get_message_cb callback,
+				void *user_data)
+{
+	return -ENOSYS;
+}
+
+int messages_update_inbox(void *session, messages_status_cb callback,
+							void *user_data)
+{
+	return -ENOSYS;
+}
+
+int messages_set_read(void *session, const char *handle, uint8_t value,
+				messages_status_cb callback, void *user_data)
+{
+	return -ENOSYS;
+}
+
+int messages_set_delete(void *session, const char *handle, uint8_t value,
+					messages_status_cb callback,
+					void *user_data)
+{
+	return -ENOSYS;
+}
+
+void messages_abort(void *session)
+{
+}
--- /dev/null
+++ ppa/obexd/plugins/syncevolution.c
@@ -0,0 +1,470 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ *
+ *  OBEX Server
+ *
+ *  Copyright (C) 2007-2010  Intel Corporation
+ *  Copyright (C) 2007-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+#include <sys/types.h>
+
+#include <glib.h>
+#include <dbus/dbus.h>
+
+#include "lib/bluetooth.h"
+
+#include "gdbus/gdbus.h"
+
+#include "btio/btio.h"
+#include "obexd/src/plugin.h"
+#include "obexd/src/obex.h"
+#include "obexd/src/service.h"
+#include "obexd/src/mimetype.h"
+#include "obexd/src/log.h"
+#include "obexd/src/manager.h"
+#include "obexd/src/obexd.h"
+#include "filesystem.h"
+
+#define SYNCML_TARGET_SIZE 11
+
+static const uint8_t SYNCML_TARGET[SYNCML_TARGET_SIZE] = {
+			0x53, 0x59, 0x4E, 0x43, 0x4D, 0x4C, 0x2D, 0x53,
+			0x59, 0x4E, 0x43 };
+
+#define SYNCEVOLUTION_CHANNEL  19
+
+#define SYNCEVOLUTION_RECORD "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\
+<record>								\
+ <attribute id=\"0x0001\">						\
+    <sequence>								\
+      <uuid value=\"00000002-0000-1000-8000-0002ee000002\"/>		\
+    </sequence>							\
+ </attribute>								\
+									\
+ <attribute id=\"0x0004\">						\
+    <sequence>								\
+      <sequence>							\
+        <uuid value=\"0x0100\"/>					\
+      </sequence>							\
+      <sequence>							\
+        <uuid value=\"0x0003\"/>					\
+        <uint8 value=\"%u\" name=\"channel\"/>				\
+      </sequence>							\
+      <sequence>							\
+        <uuid value=\"0x0008\"/>					\
+      </sequence>							\
+    </sequence>							\
+ </attribute>								\
+									\
+ <attribute id=\"0x0100\">						\
+    <text value=\"%s\" name=\"name\"/>					\
+ </attribute>								\
+</record>"
+
+#define SYNCE_BUS_NAME	"org.syncevolution"
+#define SYNCE_PATH	"/org/syncevolution/Server"
+#define SYNCE_SERVER_INTERFACE	"org.syncevolution.Server"
+#define SYNCE_CONN_INTERFACE	"org.syncevolution.Connection"
+
+struct synce_context {
+	struct obex_session *os;
+	DBusConnection *dbus_conn;
+	char *conn_obj;
+	unsigned int reply_watch;
+	unsigned int abort_watch;
+	GString *buffer;
+	int lasterr;
+	char *id;
+};
+
+static void append_dict_entry(DBusMessageIter *dict, const char *key,
+							int type, void *val)
+{
+	DBusMessageIter entry;
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+							NULL, &entry);
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &val);
+	dbus_message_iter_close_container(dict, &entry);
+}
+
+static gboolean reply_signal(DBusConnection *conn, DBusMessage *msg,
+								void *data)
+{
+	struct synce_context *context = data;
+	const char *path = dbus_message_get_path(msg);
+	DBusMessageIter iter, array_iter;
+	char *value;
+	int length;
+
+	if (strcmp(context->conn_obj, path) != 0) {
+		obex_object_set_io_flags(context, G_IO_ERR, -EPERM);
+		context->lasterr = -EPERM;
+		return FALSE;
+	}
+
+	dbus_message_iter_init(msg, &iter);
+
+	dbus_message_iter_recurse(&iter, &array_iter);
+	dbus_message_iter_get_fixed_array(&array_iter, &value, &length);
+
+	context->buffer = g_string_new_len(value, length);
+	obex_object_set_io_flags(context, G_IO_IN, 0);
+	context->lasterr = 0;
+
+	return TRUE;
+}
+
+static gboolean abort_signal(DBusConnection *conn, DBusMessage *msg,
+								void *data)
+{
+	struct synce_context *context = data;
+
+	obex_object_set_io_flags(context, G_IO_ERR, -EPERM);
+	context->lasterr = -EPERM;
+
+	return TRUE;
+}
+
+static void connect_cb(DBusPendingCall *call, void *user_data)
+{
+	struct synce_context *context = user_data;
+	DBusConnection *conn;
+	DBusMessage *reply;
+	DBusError err;
+	char *path;
+
+	conn = context->dbus_conn;
+
+	reply = dbus_pending_call_steal_reply(call);
+
+	dbus_error_init(&err);
+	if (dbus_message_get_args(reply, &err, DBUS_TYPE_OBJECT_PATH, &path,
+						DBUS_TYPE_INVALID) == FALSE) {
+		error("%s", err.message);
+		dbus_error_free(&err);
+		goto failed;
+	}
+
+	DBG("Got conn object %s from syncevolution", path);
+	context->conn_obj = g_strdup(path);
+
+	context->reply_watch = g_dbus_add_signal_watch(conn, NULL, path,
+						SYNCE_CONN_INTERFACE, "Reply",
+						reply_signal, context, NULL);
+
+	context->abort_watch = g_dbus_add_signal_watch(conn, NULL, path,
+						SYNCE_CONN_INTERFACE, "Abort",
+						abort_signal, context, NULL);
+
+	dbus_message_unref(reply);
+
+	return;
+
+failed:
+	obex_object_set_io_flags(context, G_IO_ERR, -EPERM);
+	context->lasterr = -EPERM;
+}
+
+static void process_cb(DBusPendingCall *call, void *user_data)
+{
+	struct synce_context *context = user_data;
+	DBusMessage *reply;
+	DBusError derr;
+
+	reply = dbus_pending_call_steal_reply(call);
+	dbus_error_init(&derr);
+	if (dbus_set_error_from_message(&derr, reply)) {
+		error("process_cb(): syncevolution replied with an error:"
+					" %s, %s", derr.name, derr.message);
+		dbus_error_free(&derr);
+
+		obex_object_set_io_flags(context, G_IO_ERR, -EPERM);
+		context->lasterr = -EPERM;
+		goto done;
+	}
+
+	obex_object_set_io_flags(context, G_IO_OUT, 0);
+	context->lasterr = 0;
+
+done:
+	dbus_message_unref(reply);
+}
+
+static void *synce_connect(struct obex_session *os, int *err)
+{
+	DBusConnection *conn;
+	struct synce_context *context;
+	char *address;
+
+	manager_register_session(os);
+
+	conn = manager_dbus_get_connection();
+	if (!conn)
+		goto failed;
+
+	context = g_new0(struct synce_context, 1);
+	context->dbus_conn = conn;
+	context->lasterr = -EAGAIN;
+	context->os = os;
+
+	if (obex_getpeername(os, &address) == 0) {
+		context->id = g_strdup_printf("%s+%d", address,
+							SYNCEVOLUTION_CHANNEL);
+		g_free(address);
+	}
+
+	if (err)
+		*err = 0;
+
+	return context;
+
+failed:
+	if (err)
+		*err = -EPERM;
+
+	return NULL;
+}
+
+static int synce_put(struct obex_session *os, void *user_data)
+{
+	return 0;
+}
+
+static int synce_get(struct obex_session *os, void *user_data)
+{
+	return obex_get_stream_start(os, NULL);
+}
+
+static void close_cb(DBusPendingCall *call, void *user_data)
+{
+	DBusMessage *reply;
+	DBusError derr;
+
+	reply = dbus_pending_call_steal_reply(call);
+	dbus_error_init(&derr);
+	if (dbus_set_error_from_message(&derr, reply)) {
+		error("close_cb(): syncevolution replied with an error:"
+					" %s, %s", derr.name, derr.message);
+		dbus_error_free(&derr);
+	}
+
+	dbus_message_unref(reply);
+}
+
+static void synce_disconnect(struct obex_session *os, void *user_data)
+{
+	struct synce_context *context = user_data;
+
+	g_free(context);
+}
+
+static void *synce_open(const char *name, int oflag, mode_t mode,
+				void *user_data, size_t *size, int *err)
+{
+	struct synce_context *context = user_data;
+
+	if (err)
+		*err = context ? 0 : -EFAULT;
+
+	return user_data;
+}
+
+static int synce_close(void *object)
+{
+	struct synce_context *context = object;
+	DBusMessage *msg;
+	const char *error;
+	gboolean normal;
+	DBusPendingCall *call;
+
+	if (!context->conn_obj)
+		goto done;
+
+	msg = dbus_message_new_method_call(SYNCE_BUS_NAME, context->conn_obj,
+						SYNCE_CONN_INTERFACE, "Close");
+	if (!msg)
+		goto failed;
+
+	normal = TRUE;
+	error = "none";
+	dbus_message_append_args(msg, DBUS_TYPE_BOOLEAN, &normal,
+				DBUS_TYPE_STRING, &error, DBUS_TYPE_INVALID);
+
+	g_dbus_send_message_with_reply(context->dbus_conn, msg, &call, -1);
+	dbus_pending_call_set_notify(call, close_cb, NULL, NULL);
+	dbus_message_unref(msg);
+	dbus_pending_call_unref(call);
+
+failed:
+	g_dbus_remove_watch(context->dbus_conn, context->reply_watch);
+	context->reply_watch = 0;
+	g_dbus_remove_watch(context->dbus_conn, context->abort_watch);
+	context->abort_watch = 0;
+
+	g_free(context->conn_obj);
+	context->conn_obj = NULL;
+
+done:
+	dbus_connection_unref(context->dbus_conn);
+	g_free(context);
+	return 0;
+}
+
+static ssize_t synce_read(void *object, void *buf, size_t count)
+{
+	struct synce_context *context = object;
+	DBusConnection *conn;
+	char transport[36], transport_description[24];
+	const char *session;
+	DBusMessage *msg;
+	DBusMessageIter iter, dict;
+	gboolean authenticate;
+	DBusPendingCall *call;
+
+	if (context->buffer)
+		return string_read(context->buffer, buf, count);
+
+	conn = manager_dbus_get_connection();
+	if (conn == NULL)
+		return -EPERM;
+
+	msg = dbus_message_new_method_call(SYNCE_BUS_NAME, SYNCE_PATH,
+				SYNCE_SERVER_INTERFACE, "Connect");
+	if (!msg)
+		return -EPERM;
+
+	dbus_message_iter_init_append(msg, &iter);
+	dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY,
+		DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+		DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_STRING_AS_STRING
+		DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	append_dict_entry(&dict, "id", DBUS_TYPE_STRING, context->id);
+
+	snprintf(transport, sizeof(transport), "%s.obexd", OBEXD_SERVICE);
+	append_dict_entry(&dict, "transport", DBUS_TYPE_STRING, transport);
+
+	snprintf(transport_description, sizeof(transport_description),
+						"version %s", VERSION);
+	append_dict_entry(&dict, "transport_description", DBUS_TYPE_STRING,
+							transport_description);
+
+	dbus_message_iter_close_container(&iter, &dict);
+
+	authenticate = FALSE;
+	session = "";
+	dbus_message_append_args(msg, DBUS_TYPE_BOOLEAN, &authenticate,
+			DBUS_TYPE_STRING, &session, DBUS_TYPE_INVALID);
+
+	if (!g_dbus_send_message_with_reply(conn, msg, &call, -1)) {
+		error("D-Bus call to %s failed.", SYNCE_SERVER_INTERFACE);
+		dbus_message_unref(msg);
+		return -EPERM;
+	}
+
+	dbus_pending_call_set_notify(call, connect_cb, context, NULL);
+
+	dbus_pending_call_unref(call);
+	dbus_message_unref(msg);
+
+	return -EAGAIN;
+}
+
+static ssize_t synce_write(void *object, const void *buf, size_t count)
+{
+	struct synce_context *context = object;
+	DBusMessage *msg;
+	DBusMessageIter iter, array_iter;
+	DBusPendingCall *call;
+	const char *type = obex_get_type(context->os);
+
+	if (context->lasterr == 0)
+		return count;
+
+	if (!context->conn_obj)
+		return -EFAULT;
+
+	msg = dbus_message_new_method_call(SYNCE_BUS_NAME, context->conn_obj,
+					SYNCE_CONN_INTERFACE, "Process");
+	if (!msg)
+		return -EFAULT;
+
+	dbus_message_iter_init_append(msg, &iter);
+	dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_BYTE_AS_STRING, &array_iter);
+
+	dbus_message_iter_append_fixed_array(&array_iter, DBUS_TYPE_BYTE,
+						&buf, count);
+	dbus_message_iter_close_container(&iter, &array_iter);
+
+	dbus_message_append_args(msg, DBUS_TYPE_STRING, &type,
+						DBUS_TYPE_INVALID);
+
+	if (!g_dbus_send_message_with_reply(context->dbus_conn, msg,
+								&call, -1)) {
+		error("D-Bus call to %s failed.", SYNCE_CONN_INTERFACE);
+		dbus_message_unref(msg);
+		return -EPERM;
+	}
+
+	dbus_pending_call_set_notify(call, process_cb, context, NULL);
+
+	dbus_message_unref(msg);
+	dbus_pending_call_unref(call);
+
+	return -EAGAIN;
+}
+
+static struct obex_mime_type_driver synce_driver = {
+	.target = SYNCML_TARGET,
+	.target_size = SYNCML_TARGET_SIZE,
+	.open = synce_open,
+	.close = synce_close,
+	.read = synce_read,
+	.write = synce_write,
+};
+
+static struct obex_service_driver synce = {
+	.name = "OBEX server for SyncML, using SyncEvolution",
+	.service = OBEX_SYNCEVOLUTION,
+	.channel = SYNCEVOLUTION_CHANNEL,
+	.secure = TRUE,
+	.record = SYNCEVOLUTION_RECORD,
+	.target = SYNCML_TARGET,
+	.target_size = SYNCML_TARGET_SIZE,
+	.get = synce_get,
+	.put = synce_put,
+	.connect = synce_connect,
+	.disconnect = synce_disconnect,
+};
+
+static int synce_init(void)
+{
+	int err;
+
+	err = obex_mime_type_driver_register(&synce_driver);
+	if (err < 0)
+		return err;
+
+	return obex_service_driver_register(&synce);
+}
+
+static void synce_exit(void)
+{
+	obex_service_driver_unregister(&synce);
+	obex_mime_type_driver_unregister(&synce_driver);
+}
+
+OBEX_PLUGIN_DEFINE(syncevolution, synce_init, synce_exit)
--- /dev/null
+++ ppa/test/example-adv-monitor
@@ -0,0 +1,403 @@
+#!/usr/bin/python
+# SPDX-License-Identifier: LGPL-2.1-or-later
+
+import argparse
+import dbus
+import dbus.mainloop.glib
+import dbus.service
+import json
+import time
+
+from threading import Thread
+
+try:
+    from gi.repository import GObject  # python3
+except ImportError:
+    import gobject as GObject  # python2
+
+DBUS_OM_IFACE = 'org.freedesktop.DBus.ObjectManager'
+DBUS_PROP_IFACE = 'org.freedesktop.DBus.Properties'
+
+BLUEZ_SERVICE_NAME = 'org.bluez'
+
+ADV_MONITOR_MANAGER_IFACE = 'org.bluez.AdvertisementMonitorManager1'
+ADV_MONITOR_IFACE = 'org.bluez.AdvertisementMonitor1'
+ADV_MONITOR_APP_BASE_PATH = '/org/bluez/example/adv_monitor_app'
+
+
+class AdvMonitor(dbus.service.Object):
+
+    # Indexes of the Monitor object parameters in a monitor data list.
+    MONITOR_TYPE = 0
+    RSSI_FILTER = 1
+    PATTERNS = 2
+
+    # Indexes of the RSSI filter parameters in a monitor data list.
+    RSSI_H_THRESH = 0
+    RSSI_H_TIMEOUT = 1
+    RSSI_L_THRESH = 2
+    RSSI_L_TIMEOUT = 3
+
+    # Indexes of the Patterns filter parameters in a monitor data list.
+    PATTERN_START_POS = 0
+    PATTERN_AD_TYPE = 1
+    PATTERN_DATA = 2
+
+    def __init__(self, bus, app_path, monitor_id, monitor_data):
+        self.path = app_path + '/monitor' + str(monitor_id)
+        self.bus = bus
+
+        self._set_type(monitor_data[self.MONITOR_TYPE])
+        self._set_rssi(monitor_data[self.RSSI_FILTER])
+        self._set_patterns(monitor_data[self.PATTERNS])
+
+        super(AdvMonitor, self).__init__(self.bus, self.path)
+
+
+    def get_path(self):
+        return dbus.ObjectPath(self.path)
+
+
+    def get_properties(self):
+        properties = dict()
+        properties['Type'] = dbus.String(self.monitor_type)
+        properties['RSSIHighThreshold'] = dbus.Int16(self.rssi_h_thresh)
+        properties['RSSIHighTimeout'] = dbus.UInt16(self.rssi_h_timeout)
+        properties['RSSILowThreshold'] = dbus.Int16(self.rssi_l_thresh)
+        properties['RSSILowTimeout'] = dbus.UInt16(self.rssi_l_timeout)
+        properties['Patterns'] = dbus.Array(self.patterns, signature='(yyay)')
+        return {ADV_MONITOR_IFACE: properties}
+
+
+    def _set_type(self, monitor_type):
+        self.monitor_type = monitor_type
+
+
+    def _set_rssi(self, rssi):
+        self.rssi_h_thresh = rssi[self.RSSI_H_THRESH]
+        self.rssi_h_timeout = rssi[self.RSSI_H_TIMEOUT]
+        self.rssi_l_thresh = rssi[self.RSSI_L_THRESH]
+        self.rssi_l_timeout = rssi[self.RSSI_L_TIMEOUT]
+
+
+    def _set_patterns(self, patterns):
+        self.patterns = []
+        for pattern in patterns:
+            start_pos = dbus.Byte(pattern[self.PATTERN_START_POS])
+            ad_type = dbus.Byte(pattern[self.PATTERN_AD_TYPE])
+            ad_data = []
+            for byte in pattern[self.PATTERN_DATA]:
+                ad_data.append(dbus.Byte(byte))
+            adv_pattern = dbus.Struct((start_pos, ad_type, ad_data),
+                                      signature='yyay')
+            self.patterns.append(adv_pattern)
+
+
+    def remove_monitor(self):
+        self.remove_from_connection()
+
+
+    @dbus.service.method(DBUS_PROP_IFACE,
+                         in_signature='s',
+                         out_signature='a{sv}')
+    def GetAll(self, interface):
+        print('{}: {} GetAll'.format(self.path, interface))
+        if interface != ADV_MONITOR_IFACE:
+            print('{}: GetAll: Invalid arg {}'.format(self.path, interface))
+            return {}
+
+        return self.get_properties()[ADV_MONITOR_IFACE]
+
+
+    @dbus.service.method(ADV_MONITOR_IFACE,
+                         in_signature='',
+                         out_signature='')
+    def Activate(self):
+        print('{}: Monitor Activated'.format(self.path))
+
+
+    @dbus.service.method(ADV_MONITOR_IFACE,
+                         in_signature='',
+                         out_signature='')
+    def Release(self):
+        print('{}: Monitor Released'.format(self.path))
+
+
+    @dbus.service.method(ADV_MONITOR_IFACE,
+                         in_signature='o',
+                         out_signature='')
+    def DeviceFound(self, device):
+        print('{}: {} Device Found'.format(self.path, device))
+
+
+    @dbus.service.method(ADV_MONITOR_IFACE,
+                         in_signature='o',
+                         out_signature='')
+    def DeviceLost(self, device):
+        print('{}: {} Device Lost'.format(self.path, device))
+
+
+class AdvMonitorApp(dbus.service.Object):
+
+    def __init__(self, bus, advmon_manager, app_id):
+        self.bus = bus
+        self.advmon_mgr = advmon_manager
+        self.app_path = ADV_MONITOR_APP_BASE_PATH + str(app_id)
+
+        self.monitors = dict()
+
+        super(AdvMonitorApp, self).__init__(self.bus, self.app_path)
+
+
+    def get_app_path(self):
+        return dbus.ObjectPath(self.app_path)
+
+
+    def add_monitor(self, monitor_data):
+        monitor_id = 0
+        while monitor_id in self.monitors:
+            monitor_id += 1
+
+        monitor = AdvMonitor(self.bus, self.app_path, monitor_id, monitor_data)
+
+        # Emit the InterfacesAdded signal once the Monitor object is created.
+        self.InterfacesAdded(monitor.get_path(), monitor.get_properties())
+
+        self.monitors[monitor_id] = monitor
+
+        return monitor_id
+
+
+    def remove_monitor(self, monitor_id):
+        monitor = self.monitors.pop(monitor_id, None)
+        if not monitor:
+            return False
+
+        # Emit the InterfacesRemoved signal before removing the Monitor object.
+        self.InterfacesRemoved(monitor.get_path(),
+                               monitor.get_properties().keys())
+
+        monitor.remove_monitor()
+
+        return True
+
+
+    def register_app(self):
+        self.register_successful = None
+
+        def register_cb():
+            print('{}: RegisterMonitor successful'.format(self.app_path))
+            self.register_successful = True
+
+        def register_error_cb(error):
+            print('{}: RegisterMonitor failed: {}'.format(self.app_path,
+                                                          str(error)))
+            self.register_successful = False
+
+        self.advmon_mgr.RegisterMonitor(self.get_app_path(),
+                                        reply_handler=register_cb,
+                                        error_handler=register_error_cb)
+
+        # Wait for the reply.
+        while self.register_successful is None:
+            pass
+
+        return self.register_successful
+
+
+    def unregister_app(self):
+        self.unregister_successful = None
+
+        def unregister_cb():
+            print('{}: UnregisterMonitor successful'.format(self.app_path))
+            self.unregister_successful = True
+
+        def unregister_error_cb(error):
+            print('{}: UnregisterMonitor failed: {}'.format(self.app_path,
+                                                            str(error)))
+            self.unregister_successful = False
+
+        self.advmon_mgr.UnregisterMonitor(self.get_app_path(),
+                                          reply_handler=unregister_cb,
+                                          error_handler=unregister_error_cb)
+
+        # Wait for the reply.
+        while self.unregister_successful is None:
+            pass
+
+        return self.unregister_successful
+
+
+    @dbus.service.method(DBUS_OM_IFACE, out_signature='a{oa{sa{sv}}}')
+    def GetManagedObjects(self):
+        print('{}: GetManagedObjects'.format(self.app_path))
+        objects = dict()
+        for monitor_id in self.monitors:
+            monitor = self.monitors[monitor_id]
+            objects[monitor.get_path()] = monitor.get_properties()
+
+        return objects
+
+
+    @dbus.service.signal(DBUS_OM_IFACE, signature='oa{sa{sv}}')
+    def InterfacesAdded(self, object_path, interfaces_and_properties):
+        # Invoking this method emits the InterfacesAdded signal,
+        # nothing needs to be done here.
+        return
+
+
+    @dbus.service.signal(DBUS_OM_IFACE, signature='oas')
+    def InterfacesRemoved(self, object_path, interfaces):
+        # Invoking this method emits the InterfacesRemoved signal,
+        # nothing needs to be done here.
+        return
+
+
+def read_adapter_supported_monitor_types(adapter_props):
+    types = json.dumps(adapter_props.Get(ADV_MONITOR_MANAGER_IFACE,
+                       'SupportedMonitorTypes',
+                       dbus_interface=DBUS_PROP_IFACE))
+    return json.loads(types)
+
+
+def read_adapter_supported_monitor_features(adapter_props):
+    features = json.dumps(adapter_props.Get(ADV_MONITOR_MANAGER_IFACE,
+                          'SupportedFeatures',
+                          dbus_interface=DBUS_PROP_IFACE))
+    return json.loads(features)
+
+
+def print_supported_types_and_features(adapter_props):
+    supported_types = read_adapter_supported_monitor_types(adapter_props)
+    for supported_type in supported_types:
+        print(supported_type)
+
+    supported_features = read_adapter_supported_monitor_features(adapter_props)
+    for supported_feature in supported_features:
+        print(supported_feature)
+
+
+def find_advmon_mgr(bus, adapter):
+    return dbus.Interface(bus.get_object(BLUEZ_SERVICE_NAME, adapter),
+                          ADV_MONITOR_MANAGER_IFACE)
+
+
+def find_adapter(bus):
+    remote_om = dbus.Interface(bus.get_object(BLUEZ_SERVICE_NAME, '/'),
+                                DBUS_OM_IFACE)
+    objects = remote_om.GetManagedObjects()
+
+    adapter = None
+    adapter_props = None
+
+    for o, props in objects.items():
+        if ADV_MONITOR_MANAGER_IFACE in props:
+            adapter = o
+            break
+
+    if adapter:
+        # Turn on the bluetooth adapter.
+        adapter_props = dbus.Interface(
+                                bus.get_object(BLUEZ_SERVICE_NAME, adapter),
+                                DBUS_PROP_IFACE)
+        adapter_props.Set('org.bluez.Adapter1', 'Powered', dbus.Boolean(1))
+
+    return adapter, adapter_props
+
+
+def test(bus, mainloop, advmon_mgr, app_id):
+    # Create an App instance.
+    app = AdvMonitorApp(bus, advmon_mgr, app_id)
+
+    # Create two monitor objects before registering the app. No Activate() or
+    # Release() should get called yet as the app is not registered.
+    data0 = [
+        'invalid_patterns',
+        [-50, 1, -70, 1],
+        [[0, 0x03, [0x12, 0x18]]] # Service Class UUID is 0x1812 (HOG)
+    ]
+    data1 = [
+        'or_patterns',
+        [127, 0, 127, 0],
+        [[5, 0x09, [ord('_')]]] # 5th character of the Local Name is '_'
+    ]
+    monitor0 = app.add_monitor(data0)
+    monitor1 = app.add_monitor(data1)
+
+    # Register the app root path to expose advertisement monitors.
+    # Release() should get called on monitor0 - incorrect monitor type.
+    # Activate() should get called on monitor1.
+    ret = app.register_app()
+    if not ret:
+        print('RegisterMonitor failed.')
+        mainloop.quit()
+        exit(-1)
+
+    # Create two more monitor objects.
+    # Release() should get called on monitor2 - incorrect RSSI Filter values.
+    # Activate() should get called on monitor3.
+    data2 = [
+        'or_patterns',
+        [-50, 1, -30, 1],
+        [[0, 0x19, [0xC2, 0x03]]] # Appearance is 0xC203 (Mouse)
+    ]
+    data3 = [
+        'or_patterns',
+        [-50, 1, -70, 1],
+        [[0, 0x03, [0x12, 0x18]], [0, 0x19, [0xC2, 0x03]]]
+    ]
+    monitor2 = app.add_monitor(data2)
+    monitor3 = app.add_monitor(data3)
+
+    # Run until user hits the 'Enter' key. If any peer device is advertising
+    # during this time, DeviceFound() should get triggered for monitors
+    # matching the advertisements.
+    raw_input('Press "Enter" key to quit...\n')
+
+    # Remove a monitor. DeviceFound() for this monitor should not get
+    # triggered any more.
+    app.remove_monitor(monitor1)
+
+    # Unregister the app. Release() should get invoked on active monitors,
+    # monitor3 in this case.
+    app.unregister_app()
+
+    mainloop.quit()
+
+
+def main(app_id):
+    # Initialize threads in gobject/dbus-glib before creating local threads.
+    GObject.threads_init()
+    dbus.mainloop.glib.threads_init()
+
+    # Arrange for the GLib main loop to be the default.
+    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
+
+    bus = dbus.SystemBus()
+    mainloop = GObject.MainLoop()
+
+    # Find bluetooth adapter and power it on.
+    adapter, adapter_props = find_adapter(bus)
+    if not adapter or not adapter_props:
+        print('Bluetooth adapter not found.')
+        exit(-1)
+
+    # Read supported types and find AdvertisementMonitorManager1 interface.
+    print_supported_types_and_features(adapter_props)
+    advmon_mgr = find_advmon_mgr(bus, adapter)
+    if not advmon_mgr :
+        print('AdvertisementMonitorManager1 interface not found.')
+        exit(-1)
+
+    Thread(target=test, args=(bus, mainloop, advmon_mgr, app_id)).start()
+
+    mainloop.run() # blocks until mainloop.quit() is called
+
+
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser()
+    parser.add_argument('--app_id', default=0, type=int, help='use this App-ID '
+                        'for creating dbus objects (default: 0)')
+    args = parser.parse_args()
+
+    main(args.app_id)
--- /dev/null
+++ ppa/test/example-battery-provider
@@ -0,0 +1,232 @@
+#!/usr/bin/env python3
+# SPDX-License-Identifier: LGPL-2.1-or-later
+
+import dbus
+import dbus.exceptions
+import dbus.mainloop.glib
+import dbus.service
+
+try:
+  from gi.repository import GObject
+except ImportError:
+  import gobject as GObject
+import sys
+
+mainloop = None
+app = None
+bus = None
+
+BLUEZ_SERVICE_NAME = 'org.bluez'
+DBUS_OM_IFACE =      'org.freedesktop.DBus.ObjectManager'
+DBUS_PROP_IFACE =    'org.freedesktop.DBus.Properties'
+
+BATTERY_PROVIDER_MANAGER_IFACE = 'org.bluez.BatteryProviderManager1'
+BATTERY_PROVIDER_IFACE = 'org.bluez.BatteryProvider1'
+BATTERY_PROVIDER_PATH = '/path/to/provider'
+
+BATTERY_PATH1 = '11_11_11_11_11_11'
+BATTERY_PATH2 = '22_22_22_22_22_22'
+BATTERY_PATH3 = '33_33_33_33_33_33'
+
+class InvalidArgsException(dbus.exceptions.DBusException):
+    _dbus_error_name = 'org.freedesktop.DBus.Error.InvalidArgs'
+
+
+class Application(dbus.service.Object):
+    def __init__(self, bus):
+        self.path = BATTERY_PROVIDER_PATH
+        self.services = []
+        self.batteries = []
+        dbus.service.Object.__init__(self, bus, self.path)
+
+    def get_path(self):
+        return dbus.ObjectPath(self.path)
+
+    def add_battery(self, battery):
+        self.batteries.append(battery)
+        self.InterfacesAdded(battery.get_path(), battery.get_properties())
+        GObject.timeout_add(1000, drain_battery, battery)
+
+    def remove_battery(self, battery):
+        self.batteries.remove(battery)
+        self.InterfacesRemoved(battery.get_path(), [BATTERY_PROVIDER_IFACE])
+
+    @dbus.service.method(DBUS_OM_IFACE, out_signature='a{oa{sa{sv}}}')
+    def GetManagedObjects(self):
+        response = {}
+        print('GetManagedObjects called')
+
+        for battery in self.batteries:
+            response[battery.get_path()] = battery.get_properties()
+
+        return response
+
+    @dbus.service.signal(DBUS_OM_IFACE, signature='oa{sa{sv}}')
+    def InterfacesAdded(self, object_path, interfaces_and_properties):
+        return
+
+    @dbus.service.signal(DBUS_OM_IFACE, signature='oas')
+    def InterfacesRemoved(self, object_path, interfaces):
+        return
+
+
+class Battery(dbus.service.Object):
+    """
+    org.bluez.BatteryProvider1 interface implementation
+    """
+    def __init__(self, bus, dev, percentage, source = None):
+        self.path = BATTERY_PROVIDER_PATH + '/dev_' + dev
+        self.dev_path = '/org/bluez/hci0/dev_' + dev
+        self.bus = bus
+        self.percentage = percentage
+        self.source = source
+        dbus.service.Object.__init__(self, bus, self.path)
+
+    def get_battery_properties(self):
+        properties = {}
+        if self.percentage != None:
+            properties['Percentage'] = dbus.Byte(self.percentage)
+        if self.source != None:
+            properties['Source'] = self.source
+        properties['Device'] = dbus.ObjectPath(self.dev_path)
+        return properties
+
+    def get_properties(self):
+        return { BATTERY_PROVIDER_IFACE: self.get_battery_properties() }
+
+    def get_path(self):
+        return dbus.ObjectPath(self.path)
+
+    def set_percentage(self, percentage):
+        if percentage < 0 or percentage > 100:
+            print('percentage not valid')
+            return
+
+        self.percentage = percentage
+        print('battery %s percentage %d' % (self.path, self.percentage))
+        self.PropertiesChanged(
+                BATTERY_PROVIDER_IFACE, self.get_battery_properties())
+
+    @dbus.service.method(DBUS_PROP_IFACE,
+                         in_signature='s',
+                         out_signature='a{sv}')
+    def GetAll(self, interface):
+        if interface != BATTERY_PROVIDER_IFACE:
+            raise InvalidArgsException()
+
+        return self.get_properties()[BATTERY_PROVIDER_IFACE]
+
+    @dbus.service.signal(DBUS_PROP_IFACE, signature='sa{sv}')
+    def PropertiesChanged(self, interface, properties):
+        return
+
+
+def add_late_battery():
+    app.add_battery(Battery(bus, BATTERY_PATH3, 70, 'Protocol 2'))
+
+
+def drain_battery(battery):
+    new_percentage = 100
+    if battery.percentage != None:
+        new_percentage = battery.percentage - 5
+        if new_percentage < 0:
+            new_percentage = 0
+
+    battery.set_percentage(new_percentage)
+
+    if new_percentage <= 0:
+        return False
+
+    return True
+
+def register_provider_cb():
+    print('Battery Provider registered')
+
+    # Battery added early right after RegisterBatteryProvider succeeds
+    app.add_battery(Battery(bus, BATTERY_PATH2, None))
+    # Battery added later
+    GObject.timeout_add(5000, add_late_battery)
+
+
+def register_provider_error_cb(error):
+    print('Failed to register Battery Provider: ' + str(error))
+    mainloop.quit()
+
+
+def find_manager(bus):
+    remote_om = dbus.Interface(bus.get_object(BLUEZ_SERVICE_NAME, '/'),
+                               DBUS_OM_IFACE)
+    objects = remote_om.GetManagedObjects()
+
+    for o, props in objects.items():
+        if BATTERY_PROVIDER_MANAGER_IFACE in props.keys():
+            return o
+
+    return None
+
+
+def unregister_provider_cb():
+    print('Battery Provider unregistered')
+
+
+def unregister_provider_error_cb(error):
+    print('Failed to unregister Battery Provider: ' + str(error))
+
+
+def unregister_battery_provider(battery_provider_manager):
+    battery_provider_manager.UnregisterBatteryProvider(BATTERY_PROVIDER_PATH,
+                                    reply_handler=unregister_provider_cb,
+                                    error_handler=unregister_provider_error_cb)
+
+
+def remove_battery(app, battery):
+    app.remove_battery(battery)
+
+
+"""
+Simulates an application registering to BlueZ as a Battery Provider providing
+fake batteries drained periodically.
+"""
+def main():
+    global mainloop, bus, app
+
+    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
+
+    bus = dbus.SystemBus()
+
+    manager_path = find_manager(bus)
+    if not manager_path:
+        print('BatteryProviderManager1 interface not found')
+        return
+
+    print('BatteryProviderManager1 path = ', manager_path)
+
+    battery_provider_manager = dbus.Interface(
+            bus.get_object(BLUEZ_SERVICE_NAME, manager_path),
+            BATTERY_PROVIDER_MANAGER_IFACE)
+
+    app = Application(bus)
+
+    # Battery pre-added before RegisterBatteryProvider
+    battery1 = Battery(bus, BATTERY_PATH1, 87, 'Protocol 1')
+    app.add_battery(battery1)
+
+    mainloop = GObject.MainLoop()
+
+    print('Registering Battery Provider...')
+
+    battery_provider_manager.RegisterBatteryProvider(BATTERY_PROVIDER_PATH,
+                                    reply_handler=register_provider_cb,
+                                    error_handler=register_provider_error_cb)
+
+    # Unregister the Battery Provider after an arbitrary amount of time
+    GObject.timeout_add(
+            12000, unregister_battery_provider, battery_provider_manager)
+    # Simulate battery removal by a provider
+    GObject.timeout_add(8000, remove_battery, app, battery1)
+
+    mainloop.run()
+
+
+if __name__ == '__main__':
+    main()
--- /dev/null
+++ ppa/test/example-endpoint
@@ -0,0 +1,187 @@
+#!/usr/bin/python
+# SPDX-License-Identifier: LGPL-2.1-or-later
+
+from __future__ import absolute_import, print_function, unicode_literals
+
+import sys
+import dbus
+import dbus.exceptions
+import dbus.service
+import dbus.mainloop.glib
+
+import array
+try:
+  from gi.repository import GObject
+except ImportError:
+  import gobject as GObject
+import bluezutils
+
+ENDPOINT_IFACE =     'org.bluez.MediaEndpoint1'
+DBUS_OM_IFACE =      'org.freedesktop.DBus.ObjectManager'
+DBUS_PROP_IFACE =    'org.freedesktop.DBus.Properties'
+
+A2DP_SOURCE_UUID =   '0000110A-0000-1000-8000-00805F9B34FB'
+A2DP_SINK_UUID =     '0000110B-0000-1000-8000-00805F9B34FB'
+
+SBC_CODEC = dbus.Byte(0x00)
+#Channel Modes: Mono DualChannel Stereo JointStereo
+#Frequencies: 16Khz 32Khz 44.1Khz 48Khz
+#Subbands: 4 8
+#Blocks: 4 8 12 16
+#Bitpool Range: 2-64
+SBC_CAPABILITIES = dbus.Array([dbus.Byte(0xff), dbus.Byte(0xff), dbus.Byte(2), dbus.Byte(64)])
+# JointStereo 44.1Khz Subbands: Blocks: 16 Bitpool Range: 2-32
+SBC_CONFIGURATION = dbus.Array([dbus.Byte(0x21), dbus.Byte(0x15), dbus.Byte(2), dbus.Byte(32)])
+
+MP3_CODEC = dbus.Byte(0x01)
+#Channel Modes: Mono DualChannel Stereo JointStereo
+#Frequencies: 32Khz 44.1Khz 48Khz
+#CRC: YES
+#Layer: 3
+#Bit Rate: All except Free format
+#VBR: Yes
+#Payload Format: RFC-2250
+MP3_CAPABILITIES = dbus.Array([dbus.Byte(0x3f), dbus.Byte(0x07), dbus.Byte(0xff), dbus.Byte(0xfe)])
+# JointStereo 44.1Khz Layer: 3 Bit Rate: VBR Format: RFC-2250
+MP3_CONFIGURATION = dbus.Array([dbus.Byte(0x21), dbus.Byte(0x02), dbus.Byte(0x00), dbus.Byte(0x80)])
+
+PCM_CODEC = dbus.Byte(0x00)
+PCM_CONFIGURATION = dbus.Array([], signature="ay")
+
+CVSD_CODEC = dbus.Byte(0x01)
+
+class Rejected(dbus.DBusException):
+    _dbus_error_name = "org.bluez.Error.Rejected"
+
+class InvalidArgsException(dbus.exceptions.DBusException):
+    _dbus_error_name = 'org.freedesktop.DBus.Error.InvalidArgs'
+
+class Endpoint(dbus.service.Object):
+    def __init__(self, bus, path, properties, configuration):
+        self.path = path
+        self.bus = bus
+        self.properties = properties
+        self.configuration = configuration
+        self.exit_on_release = True
+        dbus.service.Object.__init__(self, bus, self.path)
+
+    def get_properties(self):
+        return self.properties
+
+    def get_path(self):
+        return dbus.ObjectPath(self.path)
+
+    @dbus.service.method(DBUS_PROP_IFACE, in_signature='s',
+                         out_signature='a{sv}')
+    def GetAll(self, interface):
+        if interface != ENDPOINT_IFACE:
+            raise InvalidArgsException()
+
+        return self.get_properties()
+
+    def set_exit_on_release(self, exit_on_release):
+        self.exit_on_release = exit_on_release
+
+    def default_configuration(self, configuration):
+        self.configuration = configuration
+
+    @dbus.service.method(ENDPOINT_IFACE, in_signature="", out_signature="")
+    def Release(self):
+        print("Release")
+        if self.exit_on_release:
+            mainloop.quit()
+
+    @dbus.service.method(ENDPOINT_IFACE, in_signature="o", out_signature="")
+    def ClearConfiguration(self, transport):
+        print("ClearConfiguration (%s)" % (transport))
+
+    @dbus.service.method(ENDPOINT_IFACE, in_signature="oay", out_signature="")
+    def SetConfiguration(self, transport, config):
+        print("SetConfiguration (%s, %s)" % (transport, config))
+        return
+
+    @dbus.service.method(ENDPOINT_IFACE, in_signature="ay", out_signature="ay")
+    def SelectConfiguration(self, caps):
+        print("SelectConfiguration (%s)" % (caps))
+        return self.configuration
+
+class Application(dbus.service.Object):
+    def __init__(self, bus, path, properties, configuration):
+        self.path = '/'
+        self.endpoints = []
+        dbus.service.Object.__init__(self, bus, self.path)
+        self.add_endpoint(Endpoint(bus, path, properties, configuration))
+
+    def get_path(self):
+        return dbus.ObjectPath(self.path)
+
+    def add_endpoint(self, endpoint):
+        self.endpoints.append(endpoint)
+
+    @dbus.service.method(DBUS_OM_IFACE, out_signature='a{oa{sa{sv}}}')
+    def GetManagedObjects(self):
+        response = {}
+        print('GetManagedObjects')
+
+        for endpoint in self.endpoints:
+            response[endpoint.get_path()] = { ENDPOINT_IFACE:
+                                              endpoint.get_properties() }
+
+        return response
+
+def register_app_cb():
+    print('Media application registered')
+
+
+def register_app_error_cb(error):
+    print('Failed to register application: ' + str(error))
+    mainloop.quit()
+
+if __name__ == '__main__':
+    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
+
+    bus = dbus.SystemBus()
+
+    if len(sys.argv) > 1:
+            path = bluezutils.find_adapter(sys.argv[1]).object_path
+    else:
+            path = bluezutils.find_adapter().object_path
+
+    media = dbus.Interface(bus.get_object("org.bluez", path),
+                           "org.bluez.Media1")
+
+
+    properties = dbus.Dictionary({ "UUID" : A2DP_SOURCE_UUID,
+                                   "Codec" : SBC_CODEC,
+                                   "DelayReporting" : True,
+                                   "Capabilities" : SBC_CAPABILITIES })
+
+    configuration = SBC_CONFIGURATION
+
+    if len(sys.argv) > 2:
+        if sys.argv[2] == "sbcsink":
+            properties = dbus.Dictionary({ "UUID" : A2DP_SINK_UUID,
+                                           "Codec" : SBC_CODEC,
+                                           "DelayReporting" : True,
+                                           "Capabilities" : SBC_CAPABILITIES })
+        if sys.argv[2] == "mp3source":
+            properties = dbus.Dictionary({ "UUID" : A2DP_SOURCE_UUID,
+                                           "Codec" : MP3_CODEC,
+                                           "Capabilities" : MP3_CAPABILITIES })
+            configuration = MP3_CONFIGURATION
+        if sys.argv[2] == "mp3sink":
+            properties = dbus.Dictionary({ "UUID" : A2DP_SINK_UUID,
+                                           "Codec" : MP3_CODEC,
+                                           "Capabilities" : MP3_CAPABILITIES })
+            configuration = MP3_CONFIGURATION
+
+    print(properties)
+
+    path = "/test/endpoint"
+    app = Application(bus, path, properties, configuration)
+    mainloop = GObject.MainLoop()
+
+    media.RegisterApplication(app.get_path(), {},
+                                reply_handler=register_app_cb,
+                                error_handler=register_app_error_cb)
+    mainloop.run()
--- /dev/null
+++ ppa/test/example-player
@@ -0,0 +1,204 @@
+#!/usr/bin/python
+# SPDX-License-Identifier: LGPL-2.1-or-later
+
+from __future__ import print_function
+
+import os
+import sys
+import dbus
+import dbus.service
+import dbus.mainloop.glib
+try:
+  from gi.repository import GObject
+except ImportError:
+  import gobject as GObject
+import bluezutils
+
+PLAYER_IFACE =       'org.mpris.MediaPlayer2.Player'
+DBUS_OM_IFACE =      'org.freedesktop.DBus.ObjectManager'
+DBUS_PROP_IFACE =    'org.freedesktop.DBus.Properties'
+
+class InvalidArgsException(dbus.exceptions.DBusException):
+    _dbus_error_name = 'org.freedesktop.DBus.Error.InvalidArgs'
+
+class Player(dbus.service.Object):
+    def __init__(self, bus, path, obj):
+        self.path = path
+        dbus.service.Object.__init__(self, bus, self.path)
+
+        if obj != None:
+            mp = dbus.Interface(bus.get_object("org.bluez", obj),
+                                                "org.bluez.MediaPlayer1")
+            prop = dbus.Interface(bus.get_object("org.bluez", obj),
+                                  "org.freedesktop.DBus.Properties")
+
+            self.properties = prop.GetAll("org.bluez.MediaPlayer1")
+
+            bus.add_signal_receiver(self.properties_changed, path = obj,
+                            dbus_interface = "org.freedesktop.DBus.Properties",
+                            signal_name = "PropertiesChanged")
+        else:
+            self.track = dbus.Dictionary({"xesam:title" : "Title",
+                                     "xesam:artist" : ["Artist"],
+                                     "xesam:album" : "Album",
+                                     "xesam:genre" : ["Genre"],
+                                     "xesam:trackNumber" : dbus.Int32(1),
+                                     "mpris:length" : dbus.Int64(10000) },
+                                     signature="sv")
+
+            self.properties = dbus.Dictionary({"PlaybackStatus" : "playing",
+                                        "Identity" : "SimplePlayer",
+                                        "LoopStatus" : "None",
+                                        "Rate" : dbus.Double(1.0),
+                                        "Shuffle" : dbus.Boolean(False),
+                                        "Metadata" : self.track,
+                                        "Volume" : dbus.Double(1.0),
+                                        "Position" : dbus.Int64(0),
+                                        "MinimumRate" : dbus.Double(1.0),
+                                        "MaximumRate" : dbus.Double(1.0),
+                                        "CanGoNext" : dbus.Boolean(False),
+                                        "CanGoPrevious" : dbus.Boolean(False),
+                                        "CanPlay" : dbus.Boolean(False),
+                                        "CanSeek" : dbus.Boolean(False),
+                                        "CanControl" : dbus.Boolean(False),
+                                        },
+                                        signature="sv")
+
+        print('Register media player with:\n\tProperties: %s' \
+              % (self.properties))
+        handler = InputHandler(self)
+        GObject.io_add_watch(sys.stdin, GObject.IO_IN, handler.handle)
+
+    @dbus.service.method("org.freedesktop.DBus.Properties",
+                         in_signature="ssv", out_signature="")
+    def Set(self, interface, key, value):
+        print("Set (%s, %s)" % (key, value), file=sys.stderr)
+        return
+
+    def get_properties(self):
+        return self.properties
+
+    def get_path(self):
+        return dbus.ObjectPath(self.path)
+
+    @dbus.service.method("org.freedesktop.DBus.Properties",
+                         in_signature='s', out_signature='a{sv}')
+    def GetAll(self, interface):
+        if interface != PLAYER_IFACE:
+            raise InvalidArgsException()
+
+        return self.get_properties()
+
+    @dbus.service.signal("org.freedesktop.DBus.Properties",
+                         signature="sa{sv}as")
+    def PropertiesChanged(self, interface, properties,
+                          invalidated = dbus.Array()):
+        """PropertiesChanged(interface, properties, invalidated)
+
+        Send a PropertiesChanged signal. 'properties' is a dictionary
+        containing string parameters as specified in doc/media-api.rst.
+        """
+        pass
+
+    def help(self, func):
+        help(self.__class__.__dict__[func])
+
+    def properties_changed(self, interface, properties, invalidated):
+        print("properties_changed(%s, %s)" % (properties, invalidated))
+
+        self.PropertiesChanged(interface, properties, invalidated)
+
+class InputHandler:
+    commands = { 'PropertiesChanged': '(interface, properties)',
+                        'help': '(cmd)' }
+    def __init__(self, player):
+        self.player = player
+        print('\n\nAvailable commands:')
+        for cmd in self.commands:
+                print('\t', cmd, self.commands[cmd], sep='')
+
+        print("\nUse python syntax to pass arguments to available methods.\n" \
+                "E.g.: PropertiesChanged({'Metadata' : {'Title': 'My title', \
+                'Album': 'my album' }})")
+        self.prompt()
+
+    def prompt(self):
+        print('\n>>> ', end='')
+        sys.stdout.flush()
+
+    def handle(self, fd, condition):
+        s = os.read(fd.fileno(), 1024).strip()
+        try:
+            cmd = s[:s.find('(')]
+            if not cmd in self.commands:
+                print("Unknown command ", cmd)
+        except ValueError:
+            print("Malformed command")
+            return True
+        try:
+            exec "self.player.%s" % s
+        except Exception as e:
+            print(e)
+            pass
+        self.prompt()
+        return True
+
+class Application(dbus.service.Object):
+    def __init__(self, bus, path, obj):
+        self.path = '/'
+        self.players = []
+        dbus.service.Object.__init__(self, bus, self.path)
+        self.add_player(Player(bus, path, obj))
+
+    def get_path(self):
+        return dbus.ObjectPath(self.path)
+
+    def add_player(self, player):
+        self.players.append(player)
+
+    @dbus.service.method(DBUS_OM_IFACE, out_signature='a{oa{sa{sv}}}')
+    def GetManagedObjects(self):
+        response = {}
+        print('GetManagedObjects')
+
+        for player in self.players:
+            response[player.get_path()] = { PLAYER_IFACE:
+                                            player.get_properties() }
+
+        return response
+
+def register_app_cb():
+    print('Media application registered')
+
+
+def register_app_error_cb(error):
+    print('Failed to register application: ' + str(error))
+    mainloop.quit()
+
+if __name__ == '__main__':
+    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
+
+    bus = dbus.SystemBus()
+
+    if len(sys.argv) > 1:
+        path = bluezutils.find_adapter(sys.argv[1]).object_path
+    else:
+        path = bluezutils.find_adapter().object_path
+
+    media = dbus.Interface(bus.get_object("org.bluez", path),
+                           "org.bluez.Media1")
+
+    path = "/test/player"
+
+    if len(sys.argv) > 2:
+        app = Application(bus, path, sys.argv[2])
+    else:
+        app = Application(bus, path, None)
+
+    mainloop = GObject.MainLoop()
+
+    media.RegisterApplication(app.get_path(), {},
+                                reply_handler=register_app_cb,
+                                error_handler=register_app_error_cb)
+
+    mainloop.run()
--- /dev/null
+++ ppa/test/exchange-business-cards
@@ -0,0 +1,20 @@
+#!/usr/bin/python
+# SPDX-License-Identifier: LGPL-2.1-or-later
+
+import sys
+import dbus
+
+bus = dbus.SessionBus()
+client = dbus.Interface(bus.get_object("org.bluez.obex", "/org/bluez/obex"),
+					"org.bluez.obex.Client")
+
+if (len(sys.argv) < 4):
+	print "Usage: %s <device> <clientfile> <file>" % (sys.argv[0])
+	sys.exit(1)
+
+print "Creating Session"
+path = client.CreateSession(sys.argv[1], { "Target": "OPP" })
+opp = dbus.Interface(bus.get_object("org.bluez.obex", path),
+					"org.bluez.obex.ObjectPush")
+
+opp.ExchangeBusinessCards(sys.argv[2], sys.argv[3])
--- /dev/null
+++ ppa/test/get-managed-objects
@@ -0,0 +1,30 @@
+#!/usr/bin/python
+# SPDX-License-Identifier: LGPL-2.1-or-later
+
+from __future__ import absolute_import, print_function, unicode_literals
+
+import dbus
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object("org.bluez", "/"),
+					"org.freedesktop.DBus.ObjectManager")
+
+objects = manager.GetManagedObjects()
+
+for path in objects.keys():
+	print("[ %s ]" % (path))
+
+	interfaces = objects[path]
+
+	for interface in interfaces.keys():
+		if interface in ["org.freedesktop.DBus.Introspectable",
+					"org.freedesktop.DBus.Properties"]:
+			continue
+
+		print("    %s" % (interface))
+
+		properties = interfaces[interface]
+
+		for key in properties.keys():
+			print("      %s = %s" % (key, properties[key]))
--- /dev/null
+++ ppa/test/get-obex-capabilities
@@ -0,0 +1,20 @@
+#!/usr/bin/python
+# SPDX-License-Identifier: LGPL-2.1-or-later
+
+import sys
+import dbus
+
+bus = dbus.SessionBus()
+client = dbus.Interface(bus.get_object("org.bluez.obex", "/org/bluez/obex"),
+					"org.bluez.obex.Client")
+
+if (len(sys.argv) < 3):
+	print "Usage: %s <device> <target>" % (sys.argv[0])
+	sys.exit(1)
+
+print "Creating Session"
+session_path = client.CreateSession(sys.argv[1], { "Target": sys.argv[2] })
+session = dbus.Interface(bus.get_object("org.bluez.obex", session_path),
+					"org.bluez.obex.Session")
+
+print session.GetCapabilities()
--- /dev/null
+++ ppa/test/list-folders
@@ -0,0 +1,40 @@
+#!/usr/bin/python
+# SPDX-License-Identifier: LGPL-2.1-or-later
+
+import sys
+import dbus
+
+
+def list_folder(folder):
+	bus = dbus.SessionBus()
+	client = dbus.Interface(bus.get_object("org.bluez.obex",
+						"/org/bluez/obex"),
+						"org.bluez.obex.Client")
+
+	path = client.CreateSession(sys.argv[1], { "Target": "ftp" })
+
+	ftp = dbus.Interface(bus.get_object("org.bluez.obex", path),
+				"org.bluez.obex.FileTransfer")
+
+	if folder:
+		for node in folder.split("/"):
+			ftp.ChangeFolder(node)
+
+	for i in ftp.ListFolder():
+		if i["Type"] == "folder":
+			print "%s/" % (i["Name"])
+		else:
+			print "%s" % (i["Name"])
+
+
+if __name__ == '__main__':
+
+	if len(sys.argv) < 2:
+		print "Usage: %s <device> [folder]" % (sys.argv[0])
+		sys.exit(1)
+
+	folder = None
+	if len(sys.argv) == 3:
+		folder = sys.argv[2]
+
+	list_folder(folder)
--- /dev/null
+++ ppa/test/simple-obex-agent
@@ -0,0 +1,88 @@
+#!/usr/bin/python
+# SPDX-License-Identifier: LGPL-2.1-or-later
+
+from __future__ import absolute_import, print_function, unicode_literals
+
+import sys
+import dbus
+import dbus.service
+import dbus.mainloop.glib
+try:
+  from gi.repository import GObject
+except ImportError:
+  import gobject as GObject
+
+BUS_NAME = 'org.bluez.obex'
+PATH = '/org/bluez/obex'
+AGENT_MANAGER_INTERFACE = 'org.bluez.obex.AgentManager1'
+AGENT_INTERFACE = 'org.bluez.obex.Agent1'
+TRANSFER_INTERFACE = 'org.bluez.obex.Transfer1'
+
+def ask(prompt):
+	try:
+		return raw_input(prompt)
+	except:
+		return input(prompt)
+
+class Agent(dbus.service.Object):
+	def __init__(self, conn=None, obj_path=None):
+		dbus.service.Object.__init__(self, conn, obj_path)
+		self.pending_auth = False
+
+	@dbus.service.method(AGENT_INTERFACE, in_signature="o",
+							out_signature="s")
+	def AuthorizePush(self, path):
+		transfer = dbus.Interface(bus.get_object(BUS_NAME, path),
+					'org.freedesktop.DBus.Properties')
+		properties = transfer.GetAll(TRANSFER_INTERFACE);
+
+		self.pending_auth = True
+		auth = ask("Authorize (%s, %s) (Y/n):" % (path,
+							properties['Name']))
+
+		if auth == "n" or auth == "N":
+			self.pending_auth = False
+			raise dbus.DBusException(
+					"org.bluez.obex.Error.Rejected: "
+					"Not Authorized")
+
+		self.pending_auth = False
+
+		return properties['Name']
+
+	@dbus.service.method(AGENT_INTERFACE, in_signature="",
+							out_signature="")
+	def Cancel(self):
+		print("Authorization Canceled")
+		self.pending_auth = False
+
+if __name__ == '__main__':
+	dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
+
+	bus = dbus.SessionBus()
+	manager = dbus.Interface(bus.get_object(BUS_NAME, PATH),
+						AGENT_MANAGER_INTERFACE)
+
+	path = "/test/agent"
+	agent = Agent(bus, path)
+
+	mainloop = GObject.MainLoop()
+
+	manager.RegisterAgent(path)
+	print("Agent registered")
+
+	cont = True
+	while cont:
+		try:
+			mainloop.run()
+		except KeyboardInterrupt:
+			if agent.pending_auth:
+				agent.Cancel()
+			elif len(transfers) > 0:
+				for a in transfers:
+					a.cancel()
+			else:
+				cont = False
+
+	# manager.UnregisterAgent(path)
+	# print "Agent unregistered"
--- /dev/null
+++ ppa/test/test-join
@@ -0,0 +1,436 @@
+#!/usr/bin/env python3
+# SPDX-License-Identifier: LGPL-2.1-or-later
+
+import sys
+import struct
+import numpy
+import dbus
+import dbus.service
+import dbus.exceptions
+
+from threading import Timer
+import time
+
+try:
+  from gi.repository import GObject
+except ImportError:
+  import gobject as GObject
+from dbus.mainloop.glib import DBusGMainLoop
+
+import agent
+
+MESH_SERVICE_NAME = 'org.bluez.mesh'
+DBUS_PROP_IFACE = 'org.freedesktop.DBus.Properties'
+DBUS_OM_IFACE = 'org.freedesktop.DBus.ObjectManager'
+
+MESH_NETWORK_IFACE = 'org.bluez.mesh.Network1'
+MESH_NODE_IFACE = 'org.bluez.mesh.Node1'
+MESH_APPLICATION_IFACE = 'org.bluez.mesh.Application1'
+MESH_ELEMENT_IFACE = 'org.bluez.mesh.Element1'
+
+APP_COMPANY_ID = 0x05f1
+APP_PRODUCT_ID = 0x0001
+APP_VERSION_ID = 0x0001
+
+VENDOR_ID_NONE = 0xffff
+
+mesh_net = None
+app = None
+bus = None
+mainloop = None
+node = None
+
+token = None
+
+def generic_error_cb(error):
+	print('D-Bus call failed: ' + str(error))
+
+def generic_reply_cb():
+	print('D-Bus call done')
+
+def unwrap(item):
+	if isinstance(item, dbus.Boolean):
+		return bool(item)
+	if isinstance(item, (dbus.UInt16, dbus.Int16,
+			 dbus.UInt32, dbus.Int32,
+			 dbus.UInt64, dbus.Int64)):
+		return int(item)
+	if isinstance(item, dbus.Byte):
+		return bytes([int(item)])
+	if isinstance(item, dbus.String):
+		return item
+	if isinstance(item, (dbus.Array, list, tuple)):
+		return [unwrap(x) for x in item]
+	if isinstance(item, (dbus.Dictionary, dict)):
+		return dict([(unwrap(x), unwrap(y)) for x, y in item.items()])
+
+	print('Dictionary item not handled')
+	print(type(item))
+	return item
+
+def join_cb():
+	print('Join procedure started')
+
+def join_error_cb(reason):
+	print('Join procedure failed: ', reason)
+
+def attach_app_cb(node_path, dict_array):
+	print('Mesh application registered ', node_path)
+
+	obj = bus.get_object(MESH_SERVICE_NAME, node_path)
+
+	global node
+	node = dbus.Interface(obj, MESH_NODE_IFACE)
+
+	els = unwrap(dict_array)
+	print("Get Elements")
+
+	for el in els:
+		idx = struct.unpack('b', el[0])[0]
+		print('Configuration for Element ', end='')
+		print(idx)
+
+		models = el[1]
+		element = app.get_element(idx)
+		element.set_model_config(models)
+
+def attach_app_error_cb(error):
+	print('Failed to register application: ' + str(error))
+	mainloop.quit()
+
+def attach(token):
+	print('Attach')
+	mesh_net.Attach(app.get_path(), token,
+					reply_handler=attach_app_cb,
+					error_handler=attach_app_error_cb)
+
+def interfaces_removed_cb(object_path, interfaces):
+	if not mesh_net:
+		return
+
+	if object_path == mesh_net[2]:
+		print('Service was removed')
+	mainloop.quit()
+
+def send_response(path, dest, key, data):
+	print('send response ', end='')
+	print(data)
+	node.Send(path, dest, key, data, reply_handler=generic_reply_cb,
+					error_handler=generic_error_cb)
+
+def send_publication(path, model_id, data):
+	print('send publication ', end='')
+	print(data)
+	node.Publish(path, model_id, data, reply_handler=generic_reply_cb,
+			error_handler=generic_error_cb)
+
+class PubTimer():
+	def __init__(self):
+		self.seconds = None
+		self.func = None
+		self.thread = None
+		self.busy = False
+
+	def _timeout_cb(self):
+		self.func()
+		self.busy = True
+		self._schedule_timer()
+		self.busy =False
+
+	def _schedule_timer(self):
+		self.thread = Timer(self.seconds, self._timeout_cb)
+		self.thread.start()
+
+	def start(self, seconds, func):
+		self.func = func
+		self.seconds = seconds
+		if not self.busy:
+			self._schedule_timer()
+
+	def cancel(self):
+		print('Cancel timer')
+		if self.thread is not None:
+			print('Cancel thread')
+			self.thread.cancel()
+			self.thread = None
+
+class Application(dbus.service.Object):
+
+	def __init__(self, bus):
+		self.path = '/example'
+		self.agent = None
+		self.elements = []
+		dbus.service.Object.__init__(self, bus, self.path)
+
+	def set_agent(self, agent):
+		self.agent = agent
+
+	def get_path(self):
+		return dbus.ObjectPath(self.path)
+
+	def add_element(self, element):
+		self.elements.append(element)
+
+	def get_element(self, idx):
+		for ele in self.elements:
+			if ele.get_index() == idx:
+				return ele
+
+	def get_properties(self):
+		return {
+			MESH_APPLICATION_IFACE: {
+			'CompanyID': dbus.UInt16(APP_COMPANY_ID),
+			'ProductID': dbus.UInt16(APP_PRODUCT_ID),
+			'VersionID': dbus.UInt16(APP_VERSION_ID)
+			}
+		}
+
+	@dbus.service.method(DBUS_OM_IFACE, out_signature='a{oa{sa{sv}}}')
+
+	def GetManagedObjects(self):
+		response = {}
+		print('GetManagedObjects')
+		response[self.path] = self.get_properties()
+		response[self.agent.get_path()] = self.agent.get_properties()
+		for element in self.elements:
+			response[element.get_path()] = element.get_properties()
+		return response
+
+	@dbus.service.method(MESH_APPLICATION_IFACE,
+					in_signature="t", out_signature="")
+
+	def JoinComplete(self, value):
+		global token
+		print('JoinComplete ', value)
+
+		token = value
+		attach(token)
+
+	@dbus.service.method(MESH_APPLICATION_IFACE,
+					in_signature="s", out_signature="")
+
+	def JoinFailed(self, value):
+		print('JoinFailed ', value)
+		token = value
+
+class Element(dbus.service.Object):
+	PATH_BASE = '/example/ele'
+
+	def __init__(self, bus, index):
+		self.path = self.PATH_BASE + format(index, '02x')
+		print(self.path)
+		self.models = []
+		self.bus = bus
+		self.index = index
+		dbus.service.Object.__init__(self, bus, self.path)
+
+	def _get_sig_models(self):
+		ids = []
+		for model in self.models:
+			id = model.get_id()
+			vendor = model.get_vendor()
+			if vendor == VENDOR_ID_NONE:
+				ids.append(id)
+		return ids
+
+	def _get_v_models(self):
+		ids = []
+		for model in self.models:
+			id = model.get_id()
+			v = model.get_vendor()
+			if v != VENDOR_ID_NONE:
+				vendor_id = (v, id)
+				ids.append(vendor_id)
+		return ids
+
+	def get_properties(self):
+		vendor_models = self._get_v_models()
+		sig_models = self._get_sig_models()
+
+		return {
+			MESH_ELEMENT_IFACE: {
+			'Index': dbus.Byte(self.index),
+			'Models': dbus.Array(sig_models, 'q'),
+			'VendorModels': dbus.Array(vendor_models, '(qq)'),
+			}
+		}
+
+	def add_model(self, model):
+		model.set_path(self.path)
+		self.models.append(model)
+
+	def get_index(self):
+		return self.index
+
+	def set_model_config(self, configs):
+		print('Set element models config')
+		for config in configs:
+			mod_id = config[0]
+			self.UpdateModelConfiguration(mod_id, config[1])
+
+	@dbus.service.method(MESH_ELEMENT_IFACE,
+					in_signature="qqvay", out_signature="")
+	def MessageReceived(self, source, key, destination, data):
+		print('Message Received on Element %d, src=%04x, dst=%s' %
+						self.index, source, destination)
+		for model in self.models:
+			model.process_message(source, key, data)
+
+	@dbus.service.method(MESH_ELEMENT_IFACE,
+					in_signature="qa{sv}", out_signature="")
+
+	def UpdateModelConfiguration(self, model_id, config):
+		print('UpdateModelConfig ', end='')
+		print(hex(model_id))
+		for model in self.models:
+			if model_id == model.get_id():
+				model.set_config(config)
+				return
+
+	@dbus.service.method(MESH_ELEMENT_IFACE,
+					in_signature="", out_signature="")
+
+	def get_path(self):
+		return dbus.ObjectPath(self.path)
+
+class Model():
+	def __init__(self, model_id):
+		self.cmd_ops = []
+		self.model_id = model_id
+		self.vendor = VENDOR_ID_NONE
+		self.bindings = []
+		self.pub_period = 0
+		self.pub_id = 0
+		self.path = None
+
+	def set_path(self, path):
+		self.path = path
+
+	def get_id(self):
+		return self.model_id
+
+	def get_vendor(self):
+		return self.vendor
+
+	def process_message(self, source, key, data):
+		print('Model process message')
+
+	def set_publication(self, period):
+		self.pub_period = period
+
+	def set_config(self, config):
+		if 'Bindings' in config:
+			self.bindings = config.get('Bindings')
+			print('Bindings: ', end='')
+			print(self.bindings)
+		if 'PublicationPeriod' in config:
+			self.set_publication(config.get('PublicationPeriod'))
+			print('Model publication period ', end='')
+			print(self.pub_period, end='')
+			print(' ms')
+		if 'Subscriptions' in config:
+			self.print_subscriptions(config.get('Subscriptions'))
+
+	def print_subscriptions(self, subscriptions):
+		print('Model subscriptions ', end='')
+		for sub in subscriptions:
+			if isinstance(sub, int):
+				print('%04x' % sub, end=' ')
+
+			if isinstance(sub, list):
+				label = uuid.UUID(bytes=b''.join(sub))
+				print(label, end=' ')
+		print()
+
+class OnOffServer(Model):
+	def __init__(self, model_id):
+		Model.__init__(self, model_id)
+		self.cmd_ops = { 0x8201, # get
+				 0x8202, # set
+				 0x8203 } # set unacknowledged
+
+		print("OnOff Server ", end="")
+		self.state = 0
+		print('State ', end='')
+		self.timer = PubTimer()
+
+	def process_message(self, source, key, data):
+		datalen = len(data)
+		print('OnOff Server process message len ', datalen)
+
+		if datalen!=2 and datalen!=3:
+			return
+
+		if datalen==2:
+			op_tuple=struct.unpack('<H',bytes(data))
+			opcode = op_tuple[0]
+			if opcode != 0x8201:
+				print(hex(opcode))
+				return
+			print('Get state')
+		elif datalen==3:
+			opcode,self.state=struct.unpack('<HB',bytes(data))
+			if opcode != 0x8202 and opcode != 0x8203:
+				print(hex(opcode))
+				return
+			print('Set state: ', end='')
+			print(self.state)
+
+		rsp_data = struct.pack('<HB', 0x8204, self.state)
+		send_response(self.path, source, key, rsp_data)
+
+	def publish(self):
+		print('Publish')
+		data = struct.pack('B', self.state)
+		send_publication(self.path, self.model_id, data)
+
+	def set_publication(self, period):
+		if period == 0:
+			self.pub_period = 0
+			self.timer.cancel()
+			return
+
+		# We do not handle ms in this example
+		if period < 1000:
+			return
+
+		self.pub_period = period
+		self.timer.start(period/1000, self.publish)
+
+def main():
+
+	DBusGMainLoop(set_as_default=True)
+
+	global bus
+	bus = dbus.SystemBus()
+	global mainloop
+	global app
+	global mesh_net
+
+	mesh_net = dbus.Interface(bus.get_object(MESH_SERVICE_NAME,
+						 "/org/bluez/mesh"),
+						 MESH_NETWORK_IFACE)
+	mesh_net.connect_to_signal('InterfacesRemoved', interfaces_removed_cb)
+
+	app = Application(bus)
+	prov_agent = agent.Agent(bus)
+	app.set_agent(prov_agent)
+	first_ele = Element(bus, 0x00)
+	first_ele.add_model(OnOffServer(0x1000))
+	app.add_element(first_ele)
+
+	mainloop = GObject.MainLoop()
+
+	print('Join')
+	caps = ["out-numeric"]
+	oob = ["other"]
+	uuid = bytearray.fromhex("0a0102030405060708090A0B0C0D0E0F")
+	print(uuid)
+	mesh_net.Join(app.get_path(), uuid,
+			reply_handler=join_cb,
+			error_handler=join_error_cb)
+
+	mainloop.run()
+
+if __name__ == '__main__':
+	main()
--- /dev/null
+++ ppa/tools/example.psr
@@ -0,0 +1,12 @@
+// PSKEY_BDADDR
+&0001 = 0001 2821 005b 6789
+// PSKEY_ANA_FTRIM
+&01f6 = 0025
+// PSKEY_HOST_INTERFACE
+&01f9 = 0001
+// PSKEY_UART_BAUD_RATE
+&0204 = 01d8
+// PSKEY_ANA_FREQ
+&01fe = 0004
+// PSKEY_UART_CONFIG
+&0205 = 0006
--- /dev/null
+++ ppa/tools/mesh-gatt/README
@@ -0,0 +1,43 @@
+MeshCtl - BlueZ GATT based Bluetooth Mesh Provisioner
+*****************************************************
+
+Copyright (C) 2017  Intel Corporation. All rights reserved.
+
+Compilation and installation
+============================
+
+In addition to main BlueZ requirements, MeshCtl needs the following:
+	- JSON library
+
+Configuration and options
+=========================
+
+	--enable-mesh
+
+		Build meshctl and other Bluetooth Mesh based tools and utils
+
+Example configuration files
+===========================
+
+The MeshCtl tool requires two input configuration files in JSON format:
+	- local_node.json
+		Local mesh node configuration
+	- prov_db.json
+		Provisoner's database for all the configured nodes in the mesh
+
+The default directory for MeshCtl configuration files is
+/home/<username>/.config/meshctl
+
+To use .json configuration files either copy them to the default directory
+or, to specify a custom storage directory, run meshctl tool as:
+
+	meshctl -c <config_dir_name>
+
+Information
+===========
+
+Mailing lists:
+	linux-bluetooth@vger.kernel.org
+
+For additional information about the project visit BlueZ web site:
+	http://www.bluez.org
--- /dev/null
+++ ppa/tools/mesh-gatt/local_node.json
@@ -0,0 +1,61 @@
+{
+  "$schema":"file:\/\/\/BlueZ\/Mesh\/local_schema\/mesh.jsonschema",
+  "meshName":"BT Mesh",
+  "netKeys":[
+    {
+      "index": 0,
+      "keyRefresh": 0
+    }
+  ],
+  "appKeys":[
+    {
+      "index": 0,
+      "boundNetKey": 0
+    },
+    {
+      "index": 1,
+      "boundNetKey": 0
+    }
+  ],
+"node": {
+	"IVindex":"00000005",
+	"IVupdate":"0",
+	"sequenceNumber": 0,
+    "composition": {
+        "cid": "0002",
+        "pid": "0010",
+        "vid": "0001",
+        "crpl": "000a",
+        "features": {
+            "relay": false,
+            "proxy": true,
+            "friend": false,
+            "lowPower": false
+        },
+        "elements": [
+            {
+                "elementIndex": 0,
+                "location": "0001",
+                "models": ["0000", "0001", "1001"]
+            }
+        ]
+    },
+    "configuration":{
+        "netKeys": [0],
+        "appKeys": [ 0, 1],
+        "defaultTTL": 10,
+        "elements": [
+          {
+            "elementIndex": 0,
+            "unicastAddress":"0077",
+            "models": [
+               {
+                 "modelId": "1001",
+                 "bind": [1]
+                }
+            ]
+          }
+        ]
+    }
+  }
+}
--- /dev/null
+++ ppa/tools/mesh-gatt/prov_db.json
@@ -0,0 +1,37 @@
+{
+  "$schema":"file:\/\/\/BlueZ\/Mesh\/schema\/mesh.jsonschema",
+  "meshName":"BT Mesh",
+  "IVindex":5,
+  "IVupdate":0,
+  "netKeys":[
+    {
+      "index":0,
+      "keyRefresh":0,
+      "key":"18eed9c2a56add85049ffc3c59ad0e12"
+    }
+  ],
+  "appKeys":[
+    {
+      "index":0,
+      "boundNetKey":0,
+      "key":"4f68ad85d9f48ac8589df665b6b49b8a"
+    },
+    {
+      "index":1,
+      "boundNetKey":0,
+      "key":"2aa2a6ded5a0798ceab5787ca3ae39fc"
+    }
+  ],
+  "provisioners":[
+    {
+      "provisionerName":"BT Mesh Provisioner",
+      "unicastAddress":"0077",
+      "allocatedUnicastRange":[
+        {
+          "lowAddress":"0100",
+          "highAddress":"7fff"
+        }
+      ]
+    }
+  ],
+}
--- /dev/null
+++ ppa/tools/mesh/README
@@ -0,0 +1,54 @@
+MeshCfgclient - BlueZ PB-Adv based Bluetooth Mesh Provisioner
+*************************************************************
+
+Copyright (C) 2019  Intel Corporation. All rights reserved.
+
+Compilation and installation
+============================
+
+In addition to main BlueZ requirements, MeshCfgclient needs the following:
+	- JSON library
+
+Configuration and options
+=========================
+
+	--enable-mesh
+
+		Build mesh-cfgclient and other Bluetooth Mesh based tools
+
+Storage for mesh configuration file
+===================================
+
+The mesh-cfgclient tool generates a mesh configuration file in JSON format:
+	- mesh_db.json
+that contains information about the current state of the configured mesh
+network.
+
+The default directory for mesh-cfgclient configuration file is
+$HOME/.config/meshcfg
+
+To specify a custom file, run mesh-cfgclient tool as:
+
+	mesh-cfgclient -c <config_file_name>
+
+If a configuration file is not found, it is assumed that a mesh network
+does not exist. In this case, the tool may be used to generate a new  mesh
+network by invoking "create" command from the main menu and, on a successful
+completion of this command, an initial configuration file is written.
+
+If the configuration file is present, then "create" command will fail. This
+is done so that the existing configuration is not accidentally overwritten.
+If the intention is to create a new network then, the existing mesh
+configuration file has to be either moved or dleted prior to running the
+mesh-cfgclient tool. Also, a new custom storage location may be
+specified for a new network on the start up as a command line option.
+
+
+Information
+===========
+
+Mailing lists:
+	linux-bluetooth@vger.kernel.org
+
+For additional information about the project visit BlueZ web site:
+	http://www.bluez.org
--- /dev/null
+++ ppa/tools/parse_companies.pl
@@ -0,0 +1,66 @@
+#!/usr/bin/perl
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+# parse companies from
+# https://www.bluetooth.com/specifications/assigned-numbers/company-identifiers
+
+use strict;
+# use URI::Encode qw(uri_decode);
+
+my %known_entities = (
+    'nbsp' => ' ',
+    'aacute' => '',
+    'eacute' => '',
+    'iacute' => '',
+    'oacute' => '',
+    'uacute' => '',
+    'auml' => '',
+    'uuml' => '',
+    'Uuml' => '',
+);
+
+# better to use URI::Encode if you have it
+sub uri_decode {
+    my $name = $_[0];
+    foreach my $entity (keys %known_entities) {
+        my $to = $known_entities{$entity};
+        $name =~ s/&$entity;/$to/g;
+    }
+    foreach my $entity (map { lc $_ } $name =~ /&([^;]+);/g) {
+        if ($entity ne 'amp') {
+            die "\nparse_companies.pl: Unable to convert &$entity; giving up\n";
+        }
+    }
+    $name =~ s/&amp;/&/ig;
+    $name =~ s/&nbsp;/ /ig;
+    return $name;
+}
+
+# never parse HTML with regex!
+# except when you should
+
+my $identifier;
+my $next_is_name = 0;
+
+while (<>) {
+    s/\xe2\x80\x8b//g; # kill zero width space
+
+    # grab identifier (in hex)
+    if (/\<td.*(0x[0-9A-F]{4})/i) {
+        $identifier = $1;
+        $next_is_name = 1;
+
+    # next <td> should be company name
+    } elsif ($next_is_name && m|\<td.*\>(.*)\<|) {
+        my $name = uri_decode($1);
+        $name =~ s/^\s+//g; # kill leading
+        $name =~ s/\s+$//g; # and trailing space
+        $name =~ s/"/\\"/g; # escape double quotes
+        my $id = hex($identifier);
+        if ($id != 65535) {
+            print "\tcase $id:\n";
+            print "\t\treturn \"$name\";\n";
+        }
+        $next_is_name = 0;
+    }
+}
--- /dev/null
+++ ppa/tools/update_compids.sh
@@ -0,0 +1,43 @@
+#!/bin/bash
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Download the list of company IDs from bluetooth.org and generate a diff which
+# can be applied to source tree to update bt_compidtostr(). Usage:
+#
+# 1) ./tools/update_compids.sh | git apply -p0
+# 2) Inspect changes to make sure they are sane
+# 3) git commit -m "lib: Update list of company identifiers" lib/bluetooth.c
+#
+# Requires html2text: http://www.mbayer.de/html2text/
+#
+set -e -u
+
+tmpdir=$(mktemp -d)
+trap "rm -rf $tmpdir" EXIT
+
+scriptdir=$(pwd)
+
+mkdir $tmpdir/lib
+cp lib/bluetooth.c $tmpdir/lib/bluetooth.c.orig
+cp lib/bluetooth.c $tmpdir/lib/bluetooth.c
+
+cd $tmpdir
+
+echo -e 'const char *bt_compidtostr(int compid)\n{\n\tswitch (compid) {' > new.c
+
+path=specifications/assigned-numbers/company-identifiers/
+# Use "iconv -c" to strip unwanted unicode characters
+curl --insecure https://www.bluetooth.com/$path | \
+    $scriptdir/tools/parse_companies.pl >> new.c
+
+if ! grep -q "return \"" new.c; then
+    echo "ERROR: could not parse company IDs from bluetooth.org" >&2
+    exit 1
+fi
+echo -e '\tcase 65535:\n\t\treturn "internal use";' >> new.c
+echo -e '\tdefault:\n\t\treturn "not assigned";\n\t}\n}' >> new.c
+
+sed -n '/^const char \*bt_compidtostr(int compid)/,/^}/p' \
+    lib/bluetooth.c > old.c
+
+diff -Naur old.c new.c | patch -sp0 lib/bluetooth.c
+diff -Naur lib/bluetooth.c.orig lib/bluetooth.c
--- /dev/null
+++ ppa/tools/valgrind.supp
@@ -0,0 +1,34 @@
+{
+   ecb_bind
+   Memcheck:Param
+   socketcall.bind(my_addr.sa_data)
+   fun:bind
+   fun:ecb_aes_setup
+}
+{
+   cmac_bind
+   Memcheck:Param
+   socketcall.bind(my_addr.sa_data)
+   fun:bind
+   fun:cmac_aes_setup
+}
+{
+   logging_open
+   Memcheck:Param
+   socketcall.bind(my_addr.rc_bdaddr)
+   fun:bind
+   fun:logging_open
+}
+{
+   bind
+   Memcheck:Param
+   socketcall.bind(my_addr.rc_channel)
+   fun:bind
+}
+{
+   bt_log_open
+   Memcheck:Param
+   socketcall.bind(my_addr.rc_bdaddr)
+   fun:bind
+   fun:bt_log_open
+}
